C实现了Shell；Shell上编辑、编译C代码，运行C程序。你中有我，我中有你；即是独立，又为互赖。

1 特点
    个人总结一下C语言到目前的地位特点（C语言还在持续贡献中），欢迎拍砖。
    1）计算机众多语言中，C是最基础、影响面最广的语言。K&R的《The C programming Language》，就定义了新语言的第一个程序学习模式，"Hello, World"
    2）语言编写的软件中，C的贡献是最高的，没有之一。Linux Kernel、Shell，直接用C实现；C++、Python、Java、PHP、ObjectC等等，你我能想到的如今的流行语言，几乎都是C语言实现的（或实现了早期版本，后期版本，有的用C++实现）
    3）C简单、易理解、复用性强、移植性高，是常规软件中算法实现的最好选择之一（如果还要更快，可以用CPU相关语言，如Intel IPP，Arm NEON；再快，用FPGA；再快，用专用芯片；再快，花钱买更强的硬件）

    个人再总结一下Shell到目前的地位特点（Shell同样还在持续贡献中），同样欢迎拍砖。
    1）Shell是一门语言，更是一个集成平台，是开发人员工作的基础之一（也许有意无意地被忽略，我们没有意识到）。只要开发人员在，开源世界就在；只要开源世界在，Linux就在；只要Linux在，Shell就在。（练习K&R的《The C programming Language》的习题时，编辑、编译、运行，都在用Shell。
    2）Shell是一个更深层次的系统入口，通过她你可以进入计算机世界，去探索另一个时空的神秘微妙；其他语言主要是“为用户服务”，对此涉及较少（深入理解计算机，能为用户提供更好的服务）。
    3）Shell实现功能快，灵活多变，掌握她，你会多一种或若干种设计思想和编程范式，面对问题，可以从容淡定地选择适合的方案。如果是你是开发人员，对于Shell，你可以赞扬她（很显然我属于这一类），也可以贬低她，但你不可能忽略她（其实你可以忽略她，但要承担对应后果）。

2 差异
    对比，是我们常用的最有效的分析学习方法之一。下面整理一个Shell和C的简单对比，理解一下两者的差异。

2.1 文件
    Shell中，经常听到的是；执行程序，查找文件，删除文件，批量改变文件名，备份文件...列出目录的文件，Shell中只需一条命令(ls)。
    C中，经常听到的是：字符串长度，整数小数，精确度，循环边界值，执行次数...一个浮点矩阵乘法，C中几个数组、两个for循环搞定。
    Shell的基本粒度在文件级别，特别适合文件系统的操作和改进；C是基本粒度在数据类型级别，特别适合算法层次的实现和应用。

2.2 性能
    系统启动时的调用、文本转换、等待用户响应等，如果给用户的响应在秒级别（假设C就算比Shell快10000倍），或不要用户干巴巴坐等，用户感觉应可接受，或不在乎。
    影音播放、大数据传输、实时控制同步XX机器人等，最理想就是没有延迟，快1秒、毫秒、微秒、纳秒，都有它的应用场景。
    Shell是解释性语言，性能比C低，大多应用场景已能满足要求（以人的主观角度）；对实时响应、实时控制、大数据处理等，还是要用C。
    一个现状是，硬件性能越来越强，对软件本身性能，是个福音（但现在应用软件也越做越庞大、越来越好看，消耗的性能也持续增加）。

2.3 环境
    Shell中，除了内建命令，大多是运行其他程序。这些程序各自实现一个个小目标，本身是可以独立运行的；在Shell的组织下，共同努力，集成为一个大目标。（我想起了王健林的“小目标”、美国的“联邦分权制”）
    C中，除了关键字，主要就是调用各种库提供的接口函数。这些接口本身不会独自工作，按错误顺序调用也不工作（可能工作，但结果异常）；各种库的接口之间可能不兼容，因为她们不是按一个个独立小目标来实现的，更多是通用实现。如果使用者能正确、精确调用，效果巨大。（我想起了“计划经济”）
    Shell中直接运行可执行程序；C中链接库，或通过system(cmd)子进程运行程序（有效获取运行程序的数据，又是一项专业技术活）
    从结果看，都达到了目的，没有谁好谁坏之分；从过程看，独立自主的“小目标”成就感更及时。何况，你我实现的，可能只是“小小目标，或者小小小目标”

2.4 进程
    Shell中，一不小心就创建了进程。在命令行中，每一次回车的成功执行一个脚本或程序，都创建了至少一个进程。进程之间的通信和数据分享，常规通过退出状态、管道、文件，使用简单，但非常实用。特别强调一下管道（Pipe），这是一个了不起的发明（至少可以和文件系统媲美），数据如水流送入管道，进程像过滤器，对管道中流过的水流进行加工，去除、加入、或转换。如果不创建进程，或进程通信、数据分享复杂，Shell脚本可能没有这么大的影响。
    C中，创建进程相对复杂；但设计进程间通信的机制、数据共享，就更为复杂；而为什么要用多进程，又是更高层次的复杂问题了。多进程的设计，一直都是真正C程序员的一个生死考虑。实际上，C中更常见的是“单进程、多线程”设计，在一个进程内，划分为“多重性格”捣腾。实际中，线程的同步、临界资源、优先级等，对资深程序员往往也是一个高难度考验。
    总的来说，Shell中，进程是柴米油盐酱醋茶，实用品，呼之即来，挥之则去；C中，进程是奢侈品，不是什么人都玩得起，多少人在她的小闺蜜“线程”前面，就死翘翘了。

2.5 内存
    Shell中，主要是“Shell内部”和“调用独立程序”两类地方要使用内存，Shell内部，内存由Shell解释器管理；调用的独立程序，则由独立程序内部自行管理。不论是脚本，还是程序，一旦执行完毕，内存都由操作系统回收，重新分派。进程Shell用户，不用管理内存。这是一个“使用者角度”的福音（一些编译型语言，也提供用户不管内存的“资源自动回收机制”了，如Java、Python），把内存管理风险，转移到Shell解释器和独立程序中。
    C中，就是独立程序的一种实现，内存管理逃无可逃。内存的分派、使用，本身并不难，难的是随时都要检查异常，并做好预防。内存对程序来讲，就是空气对人一样，必需、重要、而且好获取，但是大家在陆地上生活久了，都忽略了。看看海洋中潜水员、太空中的宇航员，氧气罐是他们时刻关注，因为关乎于能否继续活着？
    内存是程序运行的必备资源，Shell中，我们把球踢出去，自己不关心；C中，内存管理，是多少英雄成功崛起的“竞技场”，也是无数豪杰殊途同归的“英雄冢”。

2.6 本身
    Shell中，变量全部是字符串，数值计算需要特殊语法支持；支持条件if，循环for、while、until，分支break、contine、case等，函数定义，功能和C差不多，但语法有区别；提供简单的数组（能不用不用），甚至还提供了指针用法（千万不要用）！输入输出（I/O）操作简单，“I/O重定向 + 管道”已经成为经典应用。因为经常做文件相关的查询（文件名、文件属性等），并执行后续操作，所以Shell在测试语句写法、字符串操作、文件判断等方面的操作，提供得多快好省。
    C中，变量为基础数据类型，更多的是数值类型，字符串只是其中一种（也是很强大的一种）；条件、循环、分支、函数定义很常规，有自定义数据结构struct，还包含非常强大的数组、指针，输入输出中规中矩。特别强调是结构体、数组、指针，这是C除了数值运算，还能组织实现Linux这种超大规模代码的基础。虽然上手比较难，但对C专家来说，这些“水土火气”基本元素，就能构成多彩的代码世界。
    编程语言的语法、基本元素，是入门学习的第一步。编程语言有最基本的实现要素，理解这一点后，入门主要是适应撰写的习惯，更重要的是找到最适合的应用场景，使用最适合的工具来完成。

3 总结
    目前的语言，有神秘莫测的，有温文尔雅的，有高大威猛的，有活泼可爱的，有大家闺秀的...
    C是短小精悍的，平时虎头虎脑，大智若愚；遇到地球毁灭、或宇宙危机，就能华丽变身超级赛亚人打怪兽。
    Shell大隐隐于市，亲切低调，甚至你会视而不见；待到茫茫黑夜大家呼呼大睡时，她在丛中笑。

    目前的计算机系统，有的只提供交互式的用户应用，完全封闭了Shell，切断了系统与人的入口（只剩下赤裸裸的人与人的联系）；有的提供高大上集成的用户应用，弱化了Shell，只有那些额外研究者，才能偶尔脱离集成依赖，和系统时断时续的沟通；有的则反其道而行之（如开源世界），提供密道入口、工具箱，还有残缺的藏宝图，等待有心人的添砖加瓦。
    是勇敢探险深入虎穴，是到此一游空手而归？依据你我的选择。

    软件的发展速度，超过了任何一个行业。软件的从业人员节节攀升；软件的使用人员，也深入到了乡村（都使用了智能手机来看节目，聊视频）。

    1 Linux与Shell
        作为软件产品的使用人员，我们逃不开Windows；作为软件产品的工作人员，也躲不过Linux（类Unix系统，Unix、Linux，简称Linux）。

        成万上亿的各种Linux系统，及系统的贡献者，隐藏在信息时代的后台，辛苦劳作，默默奉献。不为名利，只为自由而战。真的很棒。
        Linux系统，是计算机世界中的宝藏，等待着有心人的挖掘和分享：
        1）最神秘是Kernel，她填补了开源世界最核心的部件，之后开源软件才能自己独立玩了；
        2）最多彩是DeviceDriver，她满足了创造的欲望，专业、业余的DIYer，都可以为开源软件添砖加瓦了；
        3）最亲密是Shell，她提供了一个“虫洞”，我们可以通过她，进入神秘多彩的计算机时空，体验高维度生物的行为思想（现实时空，也许就是高维度生物的游戏场所）；
        4）最暖心是各种Tools，你找到她们，她们就会给你惊喜或沉溺；你找不到，就自己苦逼或幸运吧。

        本次，我们主要聚焦在Shell。Oh, My precious.

    2 Shell简介
        Shell是一个命令解释器。用户通过Shell，可以使用和控制 Kernel、Device、Tools 的资源。
        shell的用武之地，个人总结有三点：
        1）快速实现软件原型
        2）非交互式的自动化使用
        3）集成实现更高级功能

        以下逐点展开描述。

        2.1 快速实现软件原型
        在管理中，我们经常听到类似的话：“方向比速度更重要，选择比努力更重要”。软件工作也一样：先满足正确性，否则性能没有意义（其实快还是有意义的，能很快知道错了）。
        我们可以通过一个简单但实际例子来比较一下：把若干文件中固定格式的16进制数，转成10进制数另存，好方便人类查看。
        有几种方法可以一试：
        1）打印出来，手工转换，用笔标注
        2）使用C，写个Command程序
        3）使用MFC，写个GUI程序（可以补充其他语言对比）
        4）使用shell，写个脚本

        第1）种方法，正确性靠转换人保证（我想起一个电视中揭露的游戏“交20押金，从1写到500，全都正确给价值好几百的礼品或现金，错误则没收押金”，有人靠这个能挣钱养家糊口的）。时间基本和字节数成正比（假设转、写1秒1数）
        第2）种方法，需要写源码，实现文件读写、内容按规则读取、字符串数字转换、数字进制转换等功能，然后编译、调试，完成程序后，在命令行调用。正确性靠人设计、通过数据来保证。时间包括写程序、调用文件、执行三部分，主要时间在“写程序”，其次在“调用文件”，“执行时间”最少
        第3）种方法，和第2）种类似，只是多了GUI的设计、实现，完成程序后，可以用鼠标操作。时间也类似，只是有“命令行”和“GUI鼠标”的操作时间差异
        第4）种方法，和第2）种相同，只是用脚本实现，不用编译。时间的差异有两点：“写程序”和“写脚本”，“编译程序的执行”和“脚本程序的执行”

        具体选取哪个方法，要看实际场景。
        1）如果只有100个数，人工方法最靠谱人工，什么写程序都是浮云。但电子信息的特点之一：信息特别多
        2）如果用GUI实现，用得会很爽，鼠标指指点点搞定。开发时间则是最长的，而且一定要有人触发。如果每天都要操作，这个人会觉得枯燥，说不准忘记了。电子信息的特点之二：开发人员的数据处理，比终端用户多得多。这个进制转换的例子，其实就是开发人员的需求（终端用户，也许根本不知道16进制和10进制的区别。“我们连12点和0点都区不了”），他们在程序调用上，并不是电脑白痴，他们不喜欢当“白痴”
        3）用command实现，不开发GUI（不用做GUI，开发很开心，因为美工实际是个艺术活，而不是技术活）时间少，主要时间是调试、逻辑差错时间。可以把执行命令复制下来，要处理就执行一下，方便快捷，但还是要操作。电子信息的特点三，信息随时来；软件开发特点一：调试、差错时间，比编码时间多得多
        4）用脚本实现，没有GUI，代码比c少，直接运行调试。如果定点到，或数据多，可以定时执行，无人值守。完美。Oh, My precious.
        当然如果要实时转换，脚本速度达不到，耗时部分可以调用已写好的Tool，或者自己实现这个Tool。真正要实时转换，没有Shell，我们还有写一个定时程序来调用。时间又耗费了
        个人用脚本实现，代码行数54，还包括8行注释，8个空行。实现花了45分钟（包括上网查属性，写word使用说明）

        其实，我们有很多快速原型或最终产品的例子：
        1）matlab 快速实现算法效果
        2）搭建虚拟机
        3）互联网后台应用

        2.2 自动化使用
        自动化的概念，从软件角度定义是批处理，无人值守，定时执行。从广义角度，不需要人参与，或者不需要我参与的，都可以归属广义的自动化。在现代生活中，自动化在衣食住行用各个方面，已经无孔不入（而且这也是工业社会进步追求的主要目标之一）。随便就能列出一大把：
        先从住家水电卫厨开始：自来水，饮用水，电水壶，保温杯；电、电灯、电饭煲、电磁炉、榨汁机、豆浆机、电冰箱、电视机、空调、电风扇、洗衣机；下水道，天然气，罐装煤气，热水器，浴霸，小闹钟，手表，电脑。。。当然，还有最重要的手机，网络（广义上讲，自动化的一切，就是网络的体现）
        再看看交通：自行车、电动车、公交车、私家车、高铁、轮船、飞机、火箭。。。
        吃穿就不用多说了：快餐（深圳最发达产业之一）、大排档、酒楼、私家菜。。。；对于穿，从出身到现在，我们有自己做过一件衣服吗？
        最近几十年的计算机革命，最近十几年的互联网革命，最近几年的物联网革命，则是计算机、软件、网络、智能设备相关的自动化典型应用。客户越来越懒了，工作人员也是如此。
        问题来了，作为工作人员，或者细分到软件从业人员，你的工作、或你的产品，多少自动化了？
        Shell做自动化的能力、成果、方便性，在所有语言中首屈一指（后续会逐渐整理一些具体应用，这里只概述），是资深软件从业人员的必备工具（犹如木匠的电动锯，医生的病历本，律师的档案袋）。典型应用如下：
        1）Linux启动中，各种服务的自动开启
        2）清除过期文件、机器老化、自动化测试等等的无人值守执行
        3）软件开发的持续集成，提交代码后，迅速编译、打包、运行测试，给出反馈
        4）各种服务器、数据库的维护、备份

        绝大多数场合，我们都是终端用户（衣食住行用），按黑盒子方式使用；偶尔一个微小的点（工作行业的产品），我们是研发生产人员。有时候，我们没有切换角色和思维，把盒子生产的要求点和标准，想得过于简单。
        相对终端用户（交互式、黑盒子方式使用，主要关注功能点、性能点、界面、操作流等），研发生产人员更要掌握（制造黑盒需要更多工具，盒子包括很多非用户需求：如快速调试、快速验证、快速发布，系统集成，运行资源监控、批量生产、异常现场信息收集、快速升级）。
        如果你要加强工作的自动化能力？Shell真的很不错。这是大家对Shell高手，敬仰之情如滔滔江水，连绵不绝的原因。

        2.3 集成实现更高级功能
        当今的人类世界，除了艺术品还是“单兵作战”模式，如哲学思想、绘画、书法、音乐等等（主要工作是单兵，大量的辅助还是被自动化了。像李宗盛这种，唱歌用自己做的吉他，做吉他用自己种的树，少了）；其他工艺品都切换到了“团队作战”模式，如出书、画展、演唱会、做手机、做App产品等等（还是需要单兵英雄，但是大量的工作需要支持）。
        而且，“团队作战”的模式，已经切换到“特种部队”这种快速响应模式，通过“少部分外部执行者（前台信息收集、决策） + 资源网络支持（后台数据处理、执行）”。
        这种模式能粘合、组装，利用已成熟工作的系统资源，集成实现更高级的目标（也可以叫组装、组合能力）。集成能力像胶水、螺丝、铆钉、绳子、包装袋、容器。。。
        一个简单比喻（可能不恰当），小时候过节时发糖果，我们的小手都抓满了，结果没有几颗。于是，我们先抓一些放在上衣口袋，再放一些在裤袋，然后再抓满，很满足。如果我们自己背个书包来装，估计爸妈就要发狂了（小时候一直没有想到过）。
        软件开发中，相对硬件、其他有形产品，更容易集成（也许是“需求爆炸”的愿意之一）。Booch在《面向对象的分析与设计》中写到，软件开发团队的任务，是设计一种假象，对用户掩盖复杂性（专业术语是封装）。当然开发人员，必须承受其背后的复杂度。
        软件集成了硬件、固件、结构；应用程序集成了操作系统、驱动、网络；Shell，则为快速实现更高级的应用程序，提供了“特种部队”的集成能力、运行环境。

3 学习难度
        关于学习，有几点说明：
        计算机是一门实践学科，光说不练假把式。
        学习计算机语言，比人类自然语言容易得多。
        学习Shell，比C++容易得多，比C也容易，比Python有难度（学会Shell，再学Python就容易了）。
        学习Shell不要纠结于语法，记住她的用武之地。
        多在互联网上查，解决问题会更快。
        你解决了问题，可以在互联网上分享，让后来人更快。
