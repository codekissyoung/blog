# const 修饰指针
```c
double rates[5] = {22.21,21,43,45,39.01};
const double *pd = rates;
*pd = 29.11; // 编译错误
pd[2] = 29.11; // 编译错误
rates[0] = 29.11; // 正确 因为rates未被限定

// 表示该函数不会使用指针改变数据
void show_array(const double *ar,int n);

// 不能改变指针的指向
double * const pc = rates;
pc = &rates[2]; // 编译错误
*pc = 11; // 可以改变它指向处的值
```

# 指向多维数组的指针
- `zippo` 存的是一个地址,`zippo[0]`存的也是一个地址,前一个地址类型为两个int的数组，后一个地址的类型是int,`zippo[0][0]`就是该地址处的值了
- `pz` 存的是一个地址,`*pz`存的也是一个地址,前一个地址类型为两个int的数组，后一个地址的类型是int，`**pz`就是该地址处的值了

```c
// 指向多维数组的指针
int zippo[3][2] =
{
    {2,3},
    {4,5},
    {6,7}
};
int (*pz)[2]; // 指向一个含有两个int类型值的数组
pz = zippo;
printf("zippo : %p , zippo[0]: %p :zippo[0][0] : %d \n",zippo,zippo[0],zippo[0][0]);
printf("pz : %p , *pz: %p : **pz: %d \n",pz,*pz,**pz);
printf("pz = %p,pz + 1:%p \n",pz,pz+1);
printf("pz[0] = %p,pz[0] + 1:%p \n",pz[0],pz[0]+1);
printf("*pz = %p,*pz + 1:%p \n",*pz,*pz+1);
printf("**pz = %d,*(*pz + 1):%d \n",**pz,*(*pz+1));
printf("**(pz + 1) = %d,*(*(pz + 1) + 1):%d \n",**(pz + 1),*(*(pz + 1)+1));
printf("pz[0][0] = %d,pz[0][1]:%d \n",pz[0][0],pz[0][1]);
printf("-----------------\n\n");
```

- `[]`的优先级高于`*`
- `int (*pz)[2]` pz先与`*`结合，说明它是一个指针，`[2]`说明了这个指针指向的内存字节大小
- `int *pz[2]` pz先与`[2]`结合，说明它是含有两个元素的数组，`int *` 说明它的两个元素是`int`类型的指针
- `char *argc[]` pz先与`[]`结合，说明是一个不定个数元素的数组，`char*`说明这些元素都是`char`类型的指针,结合`char *ch = "test";`,可以得出`argc[0]` `argc[1]`等都是字符串


# 指针的兼容性
- 不同类型的指针不能相互赋值
```bash
int n = 5;
double x = 4.2;
int *p1 = &n;
double *pd = &x;
x = n; // 隐式类型转换
pd = p1; // 错误　int 类型指针赋值给　double 类型指针

int *pt;
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2;
pt = &ar1[0][0]; // 指向int的指针
pt = ar1[0]; //　等价上
pt = ar1; // 错误, ar1 是指向内含3个int类型元素的数组的指针
pa = ar1; //　都是指向内含3个int类型元素的数组的指针
pa = ar2; // 错误，ar2 是指向内含2个int类型元素的数组的指针
p2 = &pt; // 指针的指针，
*p2 = ar2[0]; // *p2 等价于　pt , pt 是指向int类型的指针,ar2[0]也是指向int类型的指针
p2 = ar2; // p2 为指向int类型指针的指针，ar2 是指向内含2个int类型元素的指针
```





# 指针
## 理解指针
- 指针记录的是"某数据结构"的"起始内存地址+指针类型",指针类型标明了该内存地址处的数据该如何读取,如：int型就该按4个字节依次读取 传递指针时，传递的是"内存地址+指针类型"

```c
int var = 10; // 定义变量
int* a　= &var; // 定义指针
*a; // 访问指针的值
a+1; // 将内存地址加4

short* b;
b+1; // 将内存地址加２,指针存储的内存地址的加减跟"指针类型"有直接关系

int arr[3] = {1,2,3}; // 声明数组
int* parr = arr;      // 声明指针指向数组
printf("%d",*parr);      // 输出1
printf("%d",*(parr+1));  // 输出２　
printf("%d",parr[2]);    // 输出３
```

## 数组与指针
```c
int arr[3] = {1,2,3}; // arr为数组,也是指针常量,arr的值不可变,`arr++`是错误的
int* prr = arr;       // 将arr赋值给prr指针,`prr++`正确
*arr;                 // 等价于 arr[0]
*(arr+1);             // 等价于 arr[1]
*(arr+2);             // 等价于arr[2]
&arr[2] - &arr[0];    // 2  地址相差2
int sum (int *ar,int n){} // 等价于 int sum (int ar[],int n){} 
```

## 传递二维数组的地址
```c
func(int arr[][4],int length){}
// 等价于 
func(int (*arr)[4],int length){}
(*arr)[4];               // 指向列数为4的二维数组的指针, arr+1 就是移动 4*4 个字节
*(*(index + 2)+1)        // 等价于 index[2][1]
int  (*pz)[2];           // 声明指向二维数组的指针
int  *pax[2];            // 声明装有两个int型指针的数组;
int array[][4];          // 定义二维数组
int *p2array = array;    // 二维数组的指针
*(*(p2array+3)+2)        // 等价于 array[3][2] 等价于 p2array[3][2]
```
