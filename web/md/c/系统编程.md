# 系统调用
- 进程请求内核以自己名义执行某些动作(创建新进程、I/O、通信管道)的机制
- 系统调用将`CPU`由`用户态`切换到`核心态`
- 系统调用的组成是固定的，每个调用由一个数字来标识
- 系统调用可以传入一套参数，允许`用户空间`与`内核空间`相互传递信息

# 外壳函数
- glibc 封装`系统调用`成 c 函数，称为 wrapper(外壳)函数，外壳函数通过 **栈** 接收参数，并且将将这些参数写入内核规定的寄存器
- 所有系统调用进入内核的方式是相同的，有个特殊的寄存器`%eax`存入系统调用编号，用以区分每个系统调用
- 外壳函数 执行一条 中断指令 `int 0x80` ，将处理器由用户态切换到核心态，并执行系统中断 `0x80` 的中断矢量所指向的代码
- 响应中断 `0x80`, 内核调用 `system_call()` 例程， 1. 内核栈中保存寄存器的值 2. 检查系统调用编号的有效性 3. 索引服务例程的列表，调用对应例程,检查参数的有效性，执行例程任务，将结果状态返回给 system_call() 例程
- 从内核栈中恢复例程的各个寄存器值，将系统调用返回值置于栈中
- 返回至外壳函数，同时将处理器切换回用户态
- 如果系统调用出错，会返回一个负值给外壳函数，C 标准库的外壳函数对该负值 取反，并且将结果拷贝至 全局变量 errno , 同时 以 -1 作为外壳函数的返回值

# 标准 C 函数库
