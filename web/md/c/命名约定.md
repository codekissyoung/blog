# 匈牙利式命名
```c
char chName;
byte bName;
long lName;

// 指针
char* pchName;
byte* pbName;
long* plName;
void* pvName;
char** ppchName;
byte** ppbName;
```

# 怎样才能自动地查出这个bug
- 编写无错代码的最好方法是把防上错误放在第一位

# 怎样才能避免这个bug



测试者正在对刚作出的内部版本发起攻击,轮番轰炸式地输入大量的数据以求找出新的错误。你还会发现,测试员正在检查老版本的错误是否溜进了新版本。可以推想，这种查错方法比用上面的假想编译程序进行查错要花费大得多的工作量、确实如此,而且它还要有点运气。
  运气?
是的,运气。测试者之所以能够发现错误,不正是因为他注意到了诸如某个数不对、某 个功能没按所期望的方式工作或者程序瘫痪这些现象吗?再看看上面的假想编译程序给出 的上述错误:程序虽然有了“差 1”错误,但如果它仍能工作,那么测试者能看得出来吗? 就算看得出来,那么另外两个错误呢?
这听起来好象很可怕但测试人员就是这样做的大量给程序输入数据,希望潜在的错误能 够亮相。“噢,不!我们测试人员的工作可不这么简单,我们还要使用代码覆盖工具、自动 的测试集、随机的“猴”程序、抽点打印或其他什么的”。也许是这样,但还是让我们来看 看这些工具究竟做了些什么吧!覆盖分析工具能够指明程序中哪些部分未被测试到,测试人 员可以使用这一信息派生出新的测试用例。至于其它的工具无非都是“输入数据、观察结果” 这一策略的自动化。
请不要产生误解,我并不是说测试人员的所作所为都是错误的。我只是说利用黑箱方法 所能做的只是往程序里填数据,并看它弹出什么。这就好比确定一个人是不是疯子一样。问 一些问题,得到回答后进行判断。但这样还是不能确定此人是不是疯子。因为我们没法知道 其头脑中在想些什么。你总会这样地问自己:“我问的问题够吗?我问的问题对吗......”。
 12
因此,不要光依赖黑箱测试方法。还应该试着去模仿前面所讲的假想编译程序,来排除 运气对程序测试的影响,自动地抓住错误的每个机会。
