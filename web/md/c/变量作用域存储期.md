# 作用域
- 存储变量值的实际内存称为对象(object)
- 标识符(变量或者常量或者指针)就是访问指定对象的凭据
- 作用域就是程序中可访问标识符的区域
- 作用域：块作用域，函数作用域，函数原型作用域，文件作用域
- 文件作用域:变量定义在函数外面,从它定义处到所在文件末尾都可访问
- 翻译单元:源文件加上其在文件里面的`#include`的文件，预处理成一个单独的文件，这个文件就是翻译单元
- 程序由多个翻译单元组成

# 链接
- 变量属性:外部链接,内部链接,无链接
- 块作用域，函数作用域，函数原型作用域　的　变量都是无链接
- 文件作用域的变量才有外部链接和内部链接
- 外部链接的变量可以在多个翻译单元中使用，内部链接的只能在它自己的翻译单元中使用

# 储存期
- 静态存储期，线程存储期，自动存储期，动态分配储存期
- 静态存储期变量在程序执行期间一直存在，文件作用域变量都是静态存储期
- 自动存储期，块作用域和函数作用域变量就是，变量声明时可用，出了块或者函数就自动销毁

# 全局变量
- 全局变量储存在内存的数据段上
- 高频率使用的局部变量，编译器将其自动存在寄存器中

# 块作用域的静态变量
```c
void trystat(void){
    int fade = 1;
    static int stay = 2; // 块作用域的静态变量，每次调用该函数，都是访问的同一个stay,即同一块内存
    printf("fade = %d , stay = %d \n",fade++,stay++);
} 
```

# 模块示范
- 使用static定义的全局变量只能在本文件中使用，所以可以用来实现模块化，一个文件就是一个模块

```c
static int test = 10; // 只能在本文件使用的全局变量
int max(){
    static int test2 = 12; // 即使max调用完了,test2还是存在,直到程序运行结束
    return 0;
}
```
static 限制head只能在本文件中访问,用户企图在其他文件中直接操作node是不可能的
```c
// node.c
typedef struct node *Node;
static Node head;
int insert(int val){
    // ...
}
void print(){
    // ...
}
// ...
```
同时暴露出insert函数,print函数作为外部操作该链表的接口
```c
// node.h
extern int insert(int val);
extern void print();
extern void destroy();
```

# 声明和定义
- 声明是只告知编译器该变量的存在,不分配存储空间
```c
int a;
extern int max(int a,int b);
```
- 定义分配存储空间
```c
int a = 10;
int max(int a,int b){
}
```
- 多个定义是错误的，多个声明是可以的，没有定义就把声明当定义,最后都是以定义为准
