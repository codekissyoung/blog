# linux 专有的编程特性
- epoll 获取文件 I/O 事件通知的一种机制
- inotify 监控文件和目录变化的一种机制
- capabilities 为进程赋予root用户的部分权限的一种机制
- 扩展属性
- i-node标记
- clone() 系统调用
- /proc 文件系统
- 文件I/O 信号 定时器 线程 共享库 进程间通信 socket 的实现细节

# 内核可执行文件`/boot/vmlinuz`
- 名称由来: `unix` `vmunix` `vmuniz` `vmliniz` , `unix` 是`UNIX`系统的内核,`vm`表示实现了虚拟内存映射,`z`替换`x`表示压缩,`li`替换`u` 表示 `linux`内核

# 内核职责
#### 进程调度
进程同时驻留内存,由内核指定的规则决定哪个进程获得CPU的使用权以及能够使用多长时间
#### 内存管理
物理内存`(RAM)`采用虚拟内存管理机制管理, 进程与进程之间、进程与内核之间的`RAM`是彼此隔离的;每个进程只将一部分需要执行的代码和数据保留在`RAM`中;而其他数据保存在`磁盘`里，这些数据需要被访问到的时候，再替换到`RAM`中
#### 磁盘管理
内核在磁盘之上提供文件系统,允许对文件的创建、获取、更新、删除
#### 设备管理
对外设(鼠标、键盘、磁盘、磁盘驱动器)提供了访问它们简化版标准接口，管理多个进程对同一个设备的访问
#### 联网
内核以用户进程的名义收发`数据包`，保证该数据包路由至目标系统
#### 应用程序编程接口
提供系统调用，用户程序可以通过这些调用去 **请求** 内核执行各种任务

# 内核态与用户态
- CPU 支持运行在不同的状态: **内核态** 与 **用户态** ,与之对应,**虚拟内存区域** 也划分为 **用户空间** 与 **内核空间**  用户态下,CPU只能访问 **用户空间** ，**内核态** 没有限制

## 进程视角 与 内核视角
#### 进程视角
- 对进程来说 许多事情的发生都无法预期
- 进程不知道 自己 对 CPU 的占用何时 **到期** , 也不知道何时会再次获得 CPU 的使用
- 信号的的传递 和 进程通信事件的触发都由内核负责协调，对进程来说，随时可能发生
- 进程不清楚自己的数据与代码哪部分是驻留在 **RAM** ，哪部分又保存在 **SWAP**
- 进程也不清楚自己访问的文件位于磁盘的什么地方，进程只是通过名称来引用文件而已
- 进程之间彼此也不能直接通信
- 进程本身无法创建出新进程
- 进程也无法 **自行了断**
- 进程也不能与计算机外接的输入与输出设备直接通信

#### 内核视角
- 内核维护了一个数据结构，包含了所有正在运行的进程的信息,随着进程的创建与消亡，数据结构会更新
- 内核维护的底层数据结构可以将 **文件名** 转换为磁盘对应的 **物理位置**
- 内核维护的数据结构，也记录了每个进程的 **虚拟内存** 与 `RAM` 以及 `SWAP` 之间的映射关系
- 进程间的通信也只能够通过内核提供的通信机制来完成
- 进程希望创建新的进程，也需要发送请求给内核，由内核来创建新的进程，终止某进程也是请求内核去终结的
- 内核负责与外设之间的所有直接通信，按需与用户进程交换信息

#### 某些缩略语的真实含义
- `某进程可创建另一个进程` 等价于 **某进程可以请求内核创建另一个进程**
- `某进程可创建管道` 等价于 **某进程可以请求内核开辟一条管道**
- `某进程可将数据写入文件` 等价于 **某进程可以请求内核将内容写入到某文件里去**
- `某进程调用exit() ` 等价于 **某进程向内核请求销毁自己**

# 用户和组
- 内核对每一个用户都有一个标识 **UID**
- 内核出于方便管理的目的，维护了用户组，内核对每一个用户组也有一个标识 **GID**
- 用户可以属于多个用户组
- 超级用户 **UID** 为 0 ,登录名为 `root`

# 单根目录层级 目录 链接 文件
- 略

# 文件 I/O 模型
- I/O 通用性, 同一套系统调用(open read write close) 可以用于所有的文件类型，包括设备文件，由内核将这些调用转化为相应的文件系统操作，或者设备驱动操作
- 就本质而言，内核只提供一种文件类型: 字节流序列
- 没有文件结束符的概念, 读取文件时，如果无数据返回，便会认为抵达文件末尾

#### 文件描述符
- 整数，用于指代打开的文件, `open(文件路径)`调用返回一个文件描述符
- `shell` 启动的进程会 **继承** 3个已经打开的文件描述符, **标准输入 0 ** **标准输出 1** **标准错误 2** ,这 3 个描述符在交互式shell中，一般都指代的终端

# 进程
- 执行程序时，内核将程序代码载入虚拟内存，建立内核记账 **bookkeeping** 数据结构，记录进程的各种信息，比如进程ID UID GID 终止状态等

#### 进程内存布局
- Text 代码段 ：程序的指令
- Data 数据段 : 程序内静态变量
- 堆 : 供程序动态分配额外内存使用
- 栈 : 随函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间

#### 创建新进程
- 进程通过`fork()`系统调用请求内核创建新进程, 内核收到请求后，复制一份父进程作为子进程的创建基础，所以子进程从父进程处继承了数据段，栈段，以及堆段等内容作为子进程自己的副本，子进程修改这些内容，不会影响到父进程。其中标记为只读的 **Text 代码段** 是父进程与子进程共享的。
- 子进程可调用 `exec()` 系列函数，去销毁从父进程继承来的 **Text 代码段** **数据段** **堆栈** ，然后重新加载一个新的程序来替换它们，从而达到运行一个新的程序的目的

#### 进程 **PID**  和 父进程 **PPID**
用以表示进程

#### 进程终止 和 终止状态
- 终止一个进程有两种方法 1. 进程调用`_exit()`系统调用，请求退出 2. 向进程传递信号, 将其 杀死
- 进程退出或者被杀死后，都会生成`终止状态(非负小整数)`，供父进程的`wait()`系统调用检测

#### 进程的用户 和 用户标识符
- **UID** **GID** : 用来标识进程所属的用户和用户组。新进程会从父进程继承 **UID** 与 **GID**
- **有效用户EUID** **有效组EGID** : 进程在访问受保护的资源的时候会通过这它们来确定访问权限
- 补充组ID : 用于标识进程所属的额外组 , 新进程会从父进程继承 ，登录shell则从系统组文件中获取其 补充组ID

#### 特权进程
`root` 的进程 ，**UID** 为 0

#### Capabilities 能力
Linux 2.2 之后，将`root`的特权分为了一组相互独立的单元，称为`Capabilities` 能力, 通过赋予进程部分能力，使得它既可以执行某些特权操作，又可以防止它执行其他越权的操作

#### init 进程
- 1 号进程, 进程程序为`/sbin/init`, 所有进程之父，不能被杀死，只有关闭系统才能终止该进程
- 它的主要任务就是创建并且监控系统运行所需的一系列进程

#### 守护进程 Daemon
- 略

#### 环境列表
- 每个进程都有一份环境列表，即在进程用户空间中维护的一组环境变量
- 子进程会继承父进程的环境列表(生成一个副本)，父进程可以通过这个机制，向子进程传递信息
- `exec()`替换新程序时，可以继承老程序的环境，也可以重新指定

#### 资源限制
- 每个进程都会消耗打开文件、内存、CPU时间等资源，可以设置消耗这类资源的一个上限
- soft limit 限制了进程可以消耗的资源总量
- hard limit 限制了soft limit 调整上线,用户进程的 hard limit 值能调低 ， 不能调高
- 系统调用 `setrlimit()`调整限制

# 内存映射
- 系统调用 `mmap()` 创建内存映射
- 1. 文件映射: 文件部分区域 映射到 进程的虚拟内存 , 这样对该虚拟内存的操作就会转化为对相应文件区域的操作, 映射页面会按需自动从文件中加载
- 2. 匿名映射: 没有文件与 进程的虚拟内存对应，映射页面的内容会被初始化为 0
- 共享内存实现 1. 两个进程对同一文件的相同部分加以映射
- 共享内存实现 2. fork() 创建的子进程 继承 父进程的映射，从而父进程与子进程共享
- 创建映射传入的标志参数: 标志为私有，则进程对映射内容的修改 对于其他进程是不可见的；标志为共享 则是可见的
- 内存映射用途: 1. 初始化文本段 2. 内存分配(内存内容填充0) 3. 文件I/O(即映射内存I/O) 4. 进程间通信(共享映射通信)

# 静态库 和 共享库
