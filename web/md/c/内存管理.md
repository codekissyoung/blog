## 静态区
保存自动全局变量和static 变量（包括static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。

## 栈
保存局部变量。栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但空间大小有限。

## 堆
由malloc 系列函数或new 操作符分配的内存。其生命周期由free 或delete 决定。在没有释放之前一直存在，直到程序结束。其特点是使用灵活，空间比较大，但容易出错。

## 结构体成员指针未初始化
```c
struct student  
{  
    char *name;  
    int score;  
} stu , *pstu;

int main()  
{  
    strcpy(stu.name,"Jimy");  
    stu.score = 99;  
    return 0;  
}  
```
- 解决的办法是为 `name` 指针`malloc`一块空间

```c
int main()  
{  
    pstu = (struct student*)malloc(sizeof(struct student));  
    strcpy(pstu->name,"Jimy");  
    pstu->score = 99;  
    free(pstu);  
    return 0;  
}
```

# 简单的内存管理
```c
#include <stdlib.h>
void *malloc( size_t size );
```

# 按需换页的虚拟内存系统
- linux 实现了一个按需换页的 **虚拟内存系统** ，用户进程看到的所有内存都是虚拟的，也就是说它并不真正存在于程序使用的物理地址上。linux 将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你使用的特定硬件情况。当访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。

- linux 内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，并且未被写入过，内核就直接分配它，如果它已经被保存在硬盘的交换空间，就读取该页到物理内存(可能把已有的页面移回硬盘)。接着，完成虚拟内存地址到物理内存的映射之后，内核允许用户程序继续运行。
