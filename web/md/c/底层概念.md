# return 函数局部变量 错误
```c
char *Func(void){
    char str[30];
    return str;
}
```
- str    属于局部变量，位于栈内存中，在Func结束的时候被释放，所以返回str将导致错误。
- return 语句不可返回指向栈内存的指针 , 因为该内存在函数体结束时被自动销毁。
- return ; 这个语句没有问题，只表示函数的结束

# void 任意类型
```c
// ANSI错误: 进行算法操作的指针必须是确定知道其 指向数据类型 大小的
// 也就是说，不但要知道器内存地址，还要知道 可以访问 内存地址后的几个字节
void *povid;
povid++;
povid+=1;  

// 这两个函数都是操作一片内存，而不关心知道参数 指针 是什么类型 并且 其返回的也是任意类型的 指针
void *memcpy(void *dest , const  void *src, size_t,len);
void *memset(void *buffer , int c,size_t num);
```

# #define 和 const
```c
#define    M    3
const    int    N=5;    //此时并未将 N 放入 内存中
int    i = N;    //此时 为 N 分配内存，以后不再分配
int    I = M;    //预编译期间 进行宏替换 ，分配内存
int    j = N;    //使用    N    上次的内存
int    J = M;    //再进行宏替换，又一次分配内存 ！

const    int    a[5]={1,2,3,4,5};
const    int    *p;    //修饰指针    p 可变，p指向的对象不可变    修饰 *P
int    const    *p;    //修饰指针    同上    修饰    *p
int    *const    p;    //p    不可变，p 指向的对象可变    修饰p
const    int    *const    p;    //指针 p 和 p 指向的对象 都不可变    修饰 * 修饰 p

// 编译器 解析时 忽略类型名，并且 const 离谁近 ，就修饰谁;
void    Fun(const int　i);　// 告诉编译器，i 在函数体中 的值不能改变，从而防止了一些无意的修改
const    int     Fun(void);    //返回值不可 被改变
extern    const    int  i;   //在 另一个文件中 引用 const 只读变量
extern    const    int  j=10;    //错误，只读变量 的值 不能改变

const int nochange=11; /*nochange 为只读*/
nochange = 12;  /*报错*/
const int days[12]={31,30,28,30,31,30,31,30,31,30,31,30}; /*数组的值是只读的了*/
const float *pf;   /*指针指向的值是不变的*/
float const *pf    /*指针指向的值是不变的*/
float * const pt;  /*指针不能变*/
const float * const pf;    /*指针和指针指向的值均不能变*/
void display( const int array[], int limit );    /*array指向的值是不能变的*/
void display( const int *array, int limit );    /*array指向的值是不能变的*/
char *strcat( char *, const char* ); /*如果传入函数中的内存地址处的值只是用来 读取的，就const ;如果是要改变的，那就不加*/

```
- 从 汇编 角度: `const` 给出的是变量对应的内存地址，所以在运行过程中只有一份，为只读变量 ，放在静态区，具有特定的类型
- `#define` 给出的是立即数，宏是在预编译时进行替换，有若干个拷贝，没有类型
- const 可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

# extern 外来变量函数引用
- 置于函数或者变量前，告诉编译器 此变量和函数在其他模块（不在本文件）中寻找其定义。

# struct 提供 数据类型打包功能
- 在 网络协议中 ,通信控制,嵌入式系统,驱动开发 等地方，我们传送的不是简单的字节流(char 型数组),而是多种数据组合起来的一个整体，其表现形式是一个结构体。
空结构体：一个字节大小，不可能造出 没有任何容量的容器吧

# Union 压缩空间用的
```c++
union  StateMachine{
    char  character;
    int number;
    char* str;
    double  exp;
}
```
- 在 union 中 所有的 数据成员 共用一个空间，同一个时间只能储存其中一个数据成员，所有的数据成员具有相同的起始数据地址
- union 使用最大的的长度(double) 来储存所有成员，所以只能一个时间，存一个！

# 局部作用域 {}
```c
int a = 5;
{
    int a = 10;
    printf("%f\n",a); // 10
}
printf("%f \n",a); // 5

int a = 10; //全局变量
int func(){
    int a = 20 ; //局部变量，屏蔽全局变量
}
int func2(){
    printf('%d',a); // 函数内部可以直接使用全局变量
}
```


## 指针数组和二级指针
```c
int main(int argc, char const *argv[])
{
	int arr[]={1,2,3,4,5};
	int* parr[5],i;
	int** pparr;
	for (i = 0; i < 5; ++i)
	{
	    parr[i] = &arr[i];
	}
	for (i = 0; i < 5; ++i)
	{
	    printf("parr[%d]:%d\n",i,parr[i]);
	}
	pparr = parr;
	printf("parr :%d pparr: %d\n",parr,pparr);
	for (i = 0; i < 5; ++i)
	{
	    printf("%d\n", pparr[0][i]);
	}
    return 0;
}
```

```c
int main(int argc,char *argv[])
{
    int a[5] = {1,3,4,5,9};
    int* p[5],i; // int* p[5] : 五个元素的数组,每个元素都是int类型的指针
    int** pp;
    pp = p;//将二级指针赋值为一个指针数组的地址
    for (i = 0; i < 5; ++i)
    {
        p[i] = &a[i];
    }
	/* 通过指针数组访问 */
    for (i = 0; i < 5; ++i)
    {
        printf("p[%d] :%d\n",i,p[i]);
        printf("*p[%d] :%d\n",i,*p[i]);
    }
	/* 通过二级指针访问数据 */
    for (i = 0; i < 5; ++i,pp++)
    {
        printf(" **pp %d : %d\n", i, **pp );
    }
    getchar();
    return 0;
}
```

```c++
#include <stdio.h>
int main(int argc,char **argv){
    int a[2][5] = {1,3,5,7,9,2,4,6,8,10};
    int (*p)[5],i;//int (*p)[5]指向一个一维数组,该数组含有5个元素
    p = a;
    for (i = 0; i < 5; ++i)
    {
        printf("(*p)[%d] :%d\n",i,(*p)[i]);
    }
    p++;//地址移动了 int * 5 位
    for (i = 0; i < 5; ++i)
    {
        printf("(*p)[%d] :%d\n",i,(*p)[i]);
    }
    p = a;
    for (i = 0; i < 5; ++i)
    {
        printf("p[0][%d] :%d\n",i,p[0][i]);
    }
    for (i = 0; i < 5; ++i)
    {
        printf("p[1][%d] :%d\n",i,p[1][i]);
    }
    return 0;
}
```

# 函数返回指针

```c++
char *name[7] = {"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"};
char *message = "wrong input";
char* week(int day){ //返回指针的函数
    if (day<0 || day>7)
        return message;
    else
        return name[day - 1];
}
int main(int argc,char **argv){
    int day;
    char *p;
    printf("input a number of a week :\n");
    scanf("%d",&day);
    p = week(day);
    printf("%s\n",p);
    return 0;
}
```
## 指向函数的指针
```
#include <stdio.h>
#define GET_MAX 0
#define GET_MIN 1
int get_max(int i,int j){
    return i>j?i:j;
}
int get_min(int i,int j){
    return i>j?j:i;
}
int compare(int i,int j,int flag){
    int (*p)(int,int);//声明指向函数的指针
    if (flag == GET_MAX)
        p = get_max;//将函数赋值给函数指针
    else
        p = get_min;
    return p(i,j);//通过函数指针调用函数
}
int main(int argc,char **argv){
    printf("the min: %d",compare(3,4,GET_MIN));
    return 0;
}
```
将指向函数的指针作为形参
```c++
#include <stdio.h>
int get_big(int i,int j){
    return i>j?i:j;
}
int get_max(int i,int j,int k,int (*p)(int ,int))//将指向函数的指针int (*p)(int,int) 作为形参，传递函数
{　
    int ret;
    ret = p(i,j);//使用函数指针掉用函数，跟使用函数是一样的！
    ret = p(ret,k);
    return ret;
}
int main(int argc,char **argv){
    int i = 5,j = 10,k = 15,ret;
    ret = get_max(i,j,k,get_big);//将get_big函数传进去，在get_max里面调用
    printf("the max is %d\n",ret);
    return 0;
}
```
返回函数指针的函数
```c++
#include <stdio.h>
int get_big(int i,int j){
    return i>j?i:j;
}
int (*get_function(int a))(int ,int){
    printf("the number is %d \n",a);
    return get_big;
}
int main(){
    int i = 5,j = 10,max;
    int (*p)(int,int);//声明一个函数指针 p
    p = get_function(100);
    max = p(i,j);
    printf("the max is %d \n",max);
    return 0;
}
```

# 结构体
将一些离散的数据打包放一起
```c++
typedef struct Student {char *name,int age}std,* pstd;//定义结构体struct Student,取别名为std
std st1 = {"codekissyoung",21}; //定义一个std结构体变量
pstd pst1 = &st1;    //定义一个std结构体指针,指向st1
st1.name = "hello li"; 结构体访问单个元素
pst->name; 通过结构体指针访问单个元素
```

# 函数
## 声明与定义
```c++
void swamp(int *x,int *y);//声明
int main(){...}
void swamp(int *x,int *y){....}//  定义
```
## 递归函数
```c++
//n! = n * (n-1)!
long rfact(int n){
    long ans ;
    if(n>0){
        ans = n*rfact(n-1);
    }else{
        ans = 1;
    }
    return ans;
}
```
## 函数参数为指针
```c++
void swamp(int *x,int *y){
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}
int a=10,b=20;
swamp(&a,&b);
```
`swamp(&34,&89);` 错误：因为不能对标量取地址


## 数组作为函数的参数
数组元素作函数实参 ：跟普通变量没区别
数组名作为 参数 ：传递的是引用
```c++
#include <stdio.h>
float aver(float a[5]){
    int i;
    float av,s=a[0];
    for(i=1;i<5;i++)
        s=s+a[i];
    av=s/5;
    return av;
}
int main(void){
    float sco[5],av;
    int i;
    printf("\ninput 5 scores:\n");
    for(i=0;i<5;i++)
        scanf("%f",&sco[i]);
    av=aver(sco);
    printf("average score is %5.2f",av);
    return 0;
}
```

## 二维数组作为参数
多维数组也可以作为函数的参数。在函数定义时对形参数组可以指定每一维的长度，也可省去第一维的长度。因此，以下写法都是合法的：`int MA(int a[3][10])`或`int MA(int a[][10])`或`int MA(int a[][10],n)`


## 指针函数和函数指针
`double *fun();`() 的结合优先级高于 * ，所以 表达式实际为 `(*)(fun())`,表示 声明 函数返回值为double类型的指针
`double (*fun)()`表示 *fun 是指针，指向函数名，表达式实际为：声明一个用指针指向函数名的函数的返回类型为 double

# 动态内存(堆内存)
`int *pArr = (int *)malloc(sizeof(int)*len);`向系统申请堆内存
`free(pArr);`释放指针，把堆内存的控制权限还给系统

```c++
// 在 return_p 里面构造堆内存，返回地址给主调函数，这样主调函数就可以使用那块堆内存
int* return_p(len){
    int *pArr = (int *)malloc(sizeof(int)*len);
    return pArr;
}
int main(int argc, char const *argv[])
{
    int len,i,*pArr;
    pArr=return_p(len);
    free(pArr); // 释放指针，把堆内存的控制权限还给系统
}
```

```c++
// 通过传递指针的地址进去，改变指针指向的地址为函数构造堆内存
void pp_to_p(int **a,int len){
    /* int **a = a; */
    *a = (int *)malloc(sizeof(int)*len);
}
int main(int argc, char const *argv[])
{
    int len,i,*pArr;
    /*中间代码略*/
    pp_to_p(&pArr,len);
    free(pArr);/*释放指针，把堆内存的控制权限还给系统*/
}
```

```c
// 动态构造结构体
struct  Student
{
    int sid;
    int age;
};
struct Student *CreateStudent(){
    struct Student *s =(struct Student *)malloc(sizeof(struct Student));
}
void show_Student(struct Student *a){
    printf("%d %d\n",a->sid,a->age);
}
int main(int argc, char const *argv[])
{
    struct Student tom = {1,2};
    struct Student *ptim = CreateStudent();
    ptim->sid = 3;
    ptim->age = 45;
    show_Student(&tom);
    show_Student(ptim);
    return 0;
}
```
