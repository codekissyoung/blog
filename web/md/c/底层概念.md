# 数值
判断浮点数为0
```c
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON))
```

判断指针为空
```c
if (p == NULL)
if (p != NULL)
```

分号的问题
```c++
if ( NULL != p); // ;是空语句 fun(); 不会被调用
    fun();
```

在执行代码里面修改循环变量的值，很容易导致循环失控
```c++
for( n = 0 ; n < 10 ; n++){
    if(true){
        n = 8;
    }
}
```

# return 语句
- str    属于局部变量，位于栈内存中，在Func结束的时候被释放，所以返回str将导致错误。
- return 语句不可返回指向栈内存的指针 , 因为该内存在函数体结束时被自动销毁。
- return ; 这个语句没有问题，只表示函数的结束
```c++
char *Func(void){
    char str[30];
    return str;
}
```

# 指针
```c
//初始化,malloc 返回的是 10个字节大小的一块内存区域的 void 类型指针，可以使用强制类型转换将它转换为任意类型。
char *str = malloc(10);
free(str);
```

# void ：抽象数据类型
- 对函数返回的限定
- 对函数参数的限定
```c++
float *p1; int *p2; p1 = p2;   //编译错误 cannot    convert    from    int*    to    float*
void *p1; int *p2; p1 = p2;    //编译正确, void 类型指针可以接受任意 数据类型 指针的赋值
void *p1; int  *p2; p2 = p1;    //编译错误，can not convert    from    void*    to    int*
int    function(void);    //说明 函数 是不需要参数的
void    function(int a,int b);    //说明无返回值
```
GNU　认为　`void　*ｐ` 与 `char *p` 类型一致
void 指针 分为 **ANSI标准** 和 **GNU标准** ，GNU 标准更加开放，支持更多的语法
```c++
void    *povid;
povid++;   povid+=1;  //ANSI 错误   ,理由：进行算法操作的指针必须是确定知道其 指向数据类型 大小的。也就是说，不但要知道器内存地址，还要知道 可以访问 内存地址后的几个 字节;
povid ++; pvoid += 1;//GNU 正确
(char*)pvoid++;//ANSI:正确    GNU：正确
(char*)pvoid+=1;//ANSI:错误    GNU：正确
void *memcpy(void *dest , const  void *src, size_t,len);
void *memset(void *buffer , int c,size_t num);
上面 这两个函数都是操作一片内存，而不关心知道参数 指针 是什么类型
并且 其返回的也是任意类型的 指针
void 并不代表真实的值，它只是 值的一种抽象。知道有就够了
```

```c++
#define    M    3
const    int    N=5;    //此时并未将 N 放入 内存中
int    i = N;    //此时 为 N 分配内存，以后不再分配
int    I = M;    //预编译期间 进行宏替换 ，分配内存
int    j = N;    //使用    N    上次的内存
int    J = M;    //再进行宏替换，又一次分配内存 ！

const    int    a[5]={1,2,3,4,5};
const    int    *p;    //修饰指针    p 可变，p指向的对象不可变    修饰 *P
int    const    *p;    //修饰指针    同上    修饰    *p
int    *const    p;    //p    不可变，p 指向的对象可变    修饰p
const    int    *const    p;    //指针 p 和 p 指向的对象 都不可变    修饰 * 修饰 p

// 编译器 解析时 忽略类型名，并且 const 离谁近 ，就修饰谁;
void    Fun(const int　i);　// 告诉编译器，i 在函数体中 的值不能改变，从而防止了一些无意的修改
const    int     Fun(void);    //返回值不可 被改变
extern    const    int  i;   //在 另一个文件中 引用 const 只读变量
extern    const    int  j=10;    //错误，只读变量 的值 不能改变
```

const 与 define 之间的区别
- 从 汇编 角度： const 给出的是变量对应的内存地址，所以在运行过程中只有一份，为只读变量 ，放在静态区，具有特定的类型
- `#define` 给出的是立即数，宏是在预编译时进行替换，有若干个拷贝，没有类型

# extern 外来变量函数引用
置于函数或者变量前，告诉编译器 此变量和函数在其他模块（不在本文件）中寻找其定义。

# struct 提供 数据类型打包功能
在 网络协议中 ,通信控制,嵌入式系统,驱动开发 等地方，我们传送的不是简单的字节流(char 型数组),而是多种数据组合起来的一个整体，其表现形式是一个结构体。
空结构体：一个字节大小，不可能造出 没有任何容量的容器吧

# Union 压缩空间用的
在 union 中 所有的 数据成员 共用一个空间，同一个时间只能储存其中一个数据成员，所有的数据成员具有相同的起始数据地址
union 使用最大的的长度(double) 来储存所有成员，所以只能一个时间，存一个！
```c++
union  StateMachine{
    char  character;
    int number;
    char* str;
    double  exp;
}
```

# 编译器剔除代码
实际是将注释字段 ，换成 空格
```
y = x/*p  ; // 错误
y = x/ *p ; // 正确
```

# 前置++ 和 后置++
```c++
int i =3；
编译器区别：j=(++i)+(++i)+(++i)  //VC6 ：16    gcc ：18

// 逗号表达式，i 在遇到每个逗号后，认为本计算单位已经结束，i 这时候++
j=(i++,i++,i++);    // 后置 ：5    先进行别的运算（赋值）再 ++
j=(i++,i++,++i);    // 前置 ：6    先 ++ 再赋值

x=(++i,i++,i+10);    //    i=5    x=15
k=(i++)+(i++)+(i++); // k=9    i=6

// 符号的贪心原则：判定一个符号时，尽可能的包括多的字符
a+++b;// 等价于 a++  +b  ，
```
# define NULL 0
```c++
int *p = NULL; // 意思是指向 内存0 地址
int *j;
*j = NULL;    //将 *j 指向的值 赋值为 0
```

# c primier
```c++
头文件里面放置常量或者变量等，但是函数的实际代码被包含在一个预编译好的库文件中，链接器负责找到程序所需要的库代码。而头文件指引编译器把程序正确的组合在一起。
p19 int 是一种数据类型。编译器使用这个信息为变量在内存中分配一个合适的存储空间。
p29 编程是一种富有挑战性的事情，它需要抽象的，概念性的思考并细致的对待细节问题！
p32 数据类型分为 ：整数类型 和 浮点数类型，字符是整数类型 ，是一种整数编码！
p35 标准定义的数据类型 ：K&R  :int  short  long  unsigned char   float  double
                                        c90 : void  signed
                                        c99 :_Bool  _Complex  _Imaginary  分别是  布尔值(true 和 false) 复数  和 虚数
p35  对于人，整数和浮点数的区别在于它们的书写。对于计算机，区别在于它们的存储方式。
p46  可移植的类型，在不同位数的计算机上，消除 short  int  long  等表示的范围大小不一致的问题。
        #include <inttypes.h>
        使用 int16_t 表示一个16位有符号整数类型，uint32_t 表示一个32位无符号整数类型
p48  c 标准规定 float 类型至少能精确表示 6位有效数字，double 至少能精确表示 13位有效数字。
        取值范围都是  10E-37  ~10E37
p50  如果包含了 complex.h 头文件，则你可以用 complex  代替 _Complex ,imaginary 代替 _Imaginary

p56 刷新输出
        printf 将输出传递给一个被称为 缓冲区（buffer）中间存储区域。在以下几种情况，缓冲区内容传递给屏幕或者文件。这称为 刷新缓冲区。
        a 缓冲区满时
        b 遇到换行符 ，\n
        c 需要输入的时候    scanf 或 getchar
p62  scanf 遇到空白字符串（空格，制表符，换行）处停止读取。
p66  可以使用 #define 定义常量，也可以使用 const 修饰，使一个变量成为常量。const  int  MONTHS = 12;
p68  io 函数 的格式说明符 ：%c 字符，%s 字符串，%d 整数，%f  浮点数 ，%p  指针  ,%x  十六进制数
p70  格式修饰符  %4d  使用4个字宽，%5.2f 5个字宽，小数点后两位
p76    printf 打印正确返回 字符数目，打印错误返回负数
p81   scanf  返回读入项目的个数，读错时返回0，检测到 “文件末尾” 返回 EOF
```

# C++和其他语言对比
## C++ 改进了c
* 使用内联 inline 函数，代替了宏替换
* 使用new 和delete 代替了 malloc() 和 free(),作为动态内存管理！优点：new 自动计算要分配类型的大小，不使用 sizeof 运算符。它自动返回正确的指针类型，不用进行强制类型转换。可以使用new 对分配的对象进行初始化。
* 函数重载，对于简化函数命名有作用！
* 对于确定不会被设置为 null 的变量，使用 引用 & 来代替 * ！在任何情况下都不能使用指向空值的引用！如果在设计中不允许变量为空，那推荐使用引用！
* STL : algorithm ,container,iterator +工具类
* 模板 : 解决了不需要根据不同参数类型，写重复代码的繁琐！
* 对于c语言的预处理，c++中引入了一些新的方法代替它们

## c++与java
C++ 和java相比，只有标准的容器和算法，它的标准里没有网络，GUI以及应用框架这些内容，因此需要第三方的库来支持，如果你了解MFC，你就用知道qt和c++的关系其实 与 MFC和C++的关系一样，qt有完整的应用框架，GUI，网络等内容。


# 作用域
# 局部作用域{}
```c
int a = 5;
{
    int a = 10;
    printf("%f\n",a); // 10
}
printf("%f \n",a); // 5
```

```c++
if (变量){...}
while(变量){...}
if(指针){...} //有指向的指针为真，没有的为假！
```

# 变量的存储区
静态存储区：在程序开始执行时给全局变量分配存储区，程序行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不动态地进行分配和释放
动态存储区：
函数形式参数：
自动变量（未加static声明的局部变量）
函数调用实的现场保护和返回地址。
对以上这些数据，在函数开始调用时分配动态存储空间，函数结束时释放这些空间。
在C语言中，每个变量和函数有两个属性：数据类型和数据的存储类别。
函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。
有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为“静态局部变量”，用关键字static进行声明。
对静态局部变量的说明：静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整个运行期间都不释放。而自动变量（即动态局部变量）属于动态存储类别，占动态存储空间，函数调用结束后即释放。静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。而对自动变量来说，如果不赋初值则它的值是一个不确定的值。

## static的作用？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
http://blog.chinaunix.net/uid-27661165-id-3550384.html 这篇博客太详细了！

# 思考下同步执行和异步执行
在main 函数中的变量（可以称为全局变量了）var ;有 funcB(int *a);funcC(int *a); 可以修改该内存地址处的值。var 先后传入 funcB 和 funcC 。var 值 会先被 B 修改，再被 C 修改。var 的值是可以预测的。有先后顺序 是因为 ，在 执行 funB 未有返回值时，程序会阻塞在 funB 这里。
如果是 程序是如 node.js 般异步执行，var 的值就不再是可以预测的了。再说，如果funB 和funC 函数 再多几个，或者多调用几次，全局变量 var 的管理是非常复杂的。最好是分级管理： 全局变量级别，大函数级别，二级函数级别...
```c++
int a = 10; //全局变量
int func(){
    int a = 20 ; //局部变量，屏蔽全局变量
}
int func2(){
    printf('%d',a); // 函数内部可以直接使用全局变量
}
```

# 常量const
const 可以定义常量
const 可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
```c++
const  其实是"只读"修饰符
const    int    nochange=11; /*nochange 为只读*/
nochange = 12;/*报错*/
const    int    days[12]={31,30,28,30,31,30,31,30,31,30,31,30};
/*数组的值是只读的了*/
const    float    *pf;或float    const    *pf    /*指针指向的值是不变的*/
float    *    const    pt;    /*指针不能变*/
const    float    *    const    pf;    /*指针和指针指向的值均不能变*/
void    display(const    int    array[],int    limit);    /*array指向的值是不能变的*/
void    display(const    int    *array,int    limit);    /*array指向的值是不能变的*/
char    *strcat(char    *,const    char*);
/*如果传入函数中的内存地址处的值只是用来 读取的，就const ;如果是要改变的，那就不加*/
```

# 数组
## 定长数组
c中数组是连续的内存区域，是固定长度的
对于 c 的数组，未赋值的元素一律取 0
```c++
#define Y 5
int n;
const int N = 5;
int arr[n];/*错误*/
int arr[N];/*错误*/
int arr[Y];/*正确*/
```
## 二维数组
只是概念上的，实际存储上还是线性连续的
```c++
int a[5][3] = { {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} };
// 等价于
int a[5][3] = { 80,75,92,61,65,71,59,63,70,85,87,90,76,77,85};
```
## 字符数组
```c++
char c[]={'c', ' ','p','r','o','g','r','a','m'};
// 等价于
char c[]="C program";
```
数组类型是数组元素的类型，数组名是指向数组首地址的指针，scanf() 的参数列表必须是指针


# 指针
## 理解指针
指针记录的是"某数据结构"的"起始内存地址+指针类型",指针类型标明了该内存地址处的数据该如何读取,如：int型就该按4个字节依次读取
传递指针时，传递的是"内存地址+指针类型"
`int var = 10;`定义变量
`int* a　= &var;`定义指针
`*a`访问指针的值,`a+1`将内存地址加4
`short* b;`,`b+1`将内存地址加２,指针存储的内存地址的加减跟"指针类型"有直接关系
`int arr[3] = {1,2,3}`声明数组
`int* parr = arr` 声明指针指向数组
`printf("%d",*parr)` 输出1,`printf("%d",*(parr+1))`输出２　`printf("%d",parr[2]);`输出３
`*p++` : p先++再取值
`*++p` : 先取值，p再++
## 数组与指针
`int arr[3] = {1,2,3}` arr为数组,也是指针常量,arr的值不可变,`arr++`是错误的
`int* prr = arr` 将arr赋值给prr指针,`prr++`正确
`*arr;*(arr+1);*(arr+2);`等价于` arr[0] arr[1] arr[2]`
`&arr[2]-&arr[0] = 2;`地址相差2
`int sum (int *ar,int n){}`等价于`int sum (int ar[],int n){}`传递数组的地址，从而在函数里操作数组，效率高！
### 传递二维数组的地址
`func(int arr[][4],int length){}`  等价于 `func(int (*arr)[4],int length){}`
`(*arr)[4]` 是一个 指向列数为4的二维数组的指针,`arr+1` 就是移动 4*4 个字节
`*(*(index + 2)+1)` 等价于 `index[2][1]`
`int  (*pz)[2];`声明指向二维数组的指针
`int  *pax[2];`声明装有两个int型指针的数组;
`int array[][4] `定义二维数组
`int *p2array = array ;`二维数组的指针
`*(*(p2array+3)+2)`等价于 `array[3][2]` 等价于 `p2array[3][2]`

## 指针数组和二级指针
二级指针要认清层次
```c++
#include <stdio.h>
int main(int argc, char const *argv[])
{
    int arr[]={1,2,3,4,5};
    int *parr[5],i;
    int **pparr;
for (i = 0; i < 5; ++i)
{
    parr[i] = &arr[i];
}
for (i = 0; i < 5; ++i)
{
    printf("parr[%d]:%d\n",i,parr[i]);
}
pparr = parr;
printf("parr :%d pparr: %d\n",parr,pparr);
for (i = 0; i < 5; ++i)
{
    printf("%d\n", pparr[0][i]);
}
    return 0;
}
```
```c++
#include <stdio.h>
int main(int argc,char **argv){
    int a[5] = {1,3,4,5,9};
    int* p[5],i; //int* p[5] : 五个元素的数组,每个元素都是int类型的指针
    int** pp;
    pp = p;//将二级指针赋值为一个指针数组的地址
    for (i = 0; i < 5; ++i)
    {
        p[i] = &a[i];
    }
/*通过指针数组访问*/
    for (i = 0; i < 5; ++i)
    {
        printf("p[%d] :%d\n",i,p[i]);
        printf("*p[%d] :%d\n",i,*p[i]);
    }
/*通过二级指针访问数据*/
    for (i = 0; i < 5; ++i,pp++)
    {
        printf("**pp %d : %d\n",i,**pp);
    }
    getchar();
    return 0;
}
```
```c++
#include <stdio.h>
int main(int argc,char **argv){
    int a[2][5] = {1,3,5,7,9,2,4,6,8,10};
    int (*p)[5],i;//int (*p)[5]指向一个一维数组,该数组含有5个元素
    p = a;
    for (i = 0; i < 5; ++i)
    {
        printf("(*p)[%d] :%d\n",i,(*p)[i]);
    }
    p++;//地址移动了 int * 5 位
    for (i = 0; i < 5; ++i)
    {
        printf("(*p)[%d] :%d\n",i,(*p)[i]);
    }
    p = a;
    for (i = 0; i < 5; ++i)
    {
        printf("p[0][%d] :%d\n",i,p[0][i]);
    }
    for (i = 0; i < 5; ++i)
    {
        printf("p[1][%d] :%d\n",i,p[1][i]);
    }
    return 0;
}
```
## 函数返回指针
```c++
#include <stdio.h>
char *name[7] = {"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"};
char *message = "wrong input";
char* week(int day){ //返回指针的函数
    if (day<0 || day>7)
        return message;
    else
        return name[day - 1];
}
int main(int argc,char **argv){
    int day;
    char *p;
    printf("input a number of a week :\n");
    scanf("%d",&day);
    p = week(day);
    printf("%s\n",p);
    return 0;
}
```
## 指向函数的指针
```
#include <stdio.h>
#define GET_MAX 0
#define GET_MIN 1
int get_max(int i,int j){
    return i>j?i:j;
}
int get_min(int i,int j){
    return i>j?j:i;
}
int compare(int i,int j,int flag){
    int (*p)(int,int);//声明指向函数的指针
    if (flag == GET_MAX)
        p = get_max;//将函数赋值给函数指针
    else
        p = get_min;
    return p(i,j);//通过函数指针调用函数
}
int main(int argc,char **argv){
    printf("the min: %d",compare(3,4,GET_MIN));
    return 0;
}
```
将指向函数的指针作为形参
```c++
#include <stdio.h>
int get_big(int i,int j){
    return i>j?i:j;
}
int get_max(int i,int j,int k,int (*p)(int ,int))//将指向函数的指针int (*p)(int,int) 作为形参，传递函数
{　
    int ret;
    ret = p(i,j);//使用函数指针掉用函数，跟使用函数是一样的！
    ret = p(ret,k);
    return ret;
}
int main(int argc,char **argv){
    int i = 5,j = 10,k = 15,ret;
    ret = get_max(i,j,k,get_big);//将get_big函数传进去，在get_max里面调用
    printf("the max is %d\n",ret);
    return 0;
}
```
返回函数指针的函数
```c++
#include <stdio.h>
int get_big(int i,int j){
    return i>j?i:j;
}
int (*get_function(int a))(int ,int){
    printf("the number is %d \n",a);
    return get_big;
}
int main(){
    int i = 5,j = 10,max;
    int (*p)(int,int);//声明一个函数指针 p
    p = get_function(100);
    max = p(i,j);
    printf("the max is %d \n",max);
    return 0;
}
```

# 结构体
将一些离散的数据打包放一起
```c++
typedef struct Student {char *name,int age}std,* pstd;//定义结构体struct Student,取别名为std
std st1 = {"codekissyoung",21}; //定义一个std结构体变量
pstd pst1 = &st1;    //定义一个std结构体指针,指向st1
st1.name = "hello li"; 结构体访问单个元素
pst->name; 通过结构体指针访问单个元素
```

# 函数
##声明与定义
```c++
void swamp(int *x,int *y);//声明
int main(){...}
void swamp(int *x,int *y){....}//  定义
```
## 递归函数
```c++
//n! = n * (n-1)!
long rfact(int n){
    long ans ;
    if(n>0){
        ans = n*rfact(n-1);
    }else{
        ans = 1;
    }
    return ans;
}
```
## 函数参数为指针
```c++
void swamp(int *x,int *y){
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}
int a=10,b=20;
swamp(&a,&b);
```
`swamp(&34,&89);` 错误：因为不能对标量取地址


## 数组作为函数的参数
数组元素作函数实参 ：跟普通变量没区别
数组名作为 参数 ：传递的是引用
```c++
#include <stdio.h>
float aver(float a[5]){
    int i;
    float av,s=a[0];
    for(i=1;i<5;i++)
        s=s+a[i];
    av=s/5;
    return av;
}
int main(void){
    float sco[5],av;
    int i;
    printf("\ninput 5 scores:\n");
    for(i=0;i<5;i++)
        scanf("%f",&sco[i]);
    av=aver(sco);
    printf("average score is %5.2f",av);
    return 0;
}
```

## 二维数组作为参数
多维数组也可以作为函数的参数。在函数定义时对形参数组可以指定每一维的长度，也可省去第一维的长度。因此，以下写法都是合法的：`int MA(int a[3][10])`或`int MA(int a[][10])`或`int MA(int a[][10],n)`


## 指针函数和函数指针
`double *fun();`() 的结合优先级高于 * ，所以 表达式实际为 `(*)(fun())`,表示 声明 函数返回值为double类型的指针
`double (*fun)()`表示 *fun 是指针，指向函数名，表达式实际为：声明一个用指针指向函数名的函数的返回类型为 double

# 动态内存(堆内存)
`int *pArr = (int *)malloc(sizeof(int)*len);`向系统申请堆内存
`free(pArr);`释放指针，把堆内存的控制权限还给系统

```c++
// 在 return_p 里面构造堆内存，返回地址给主调函数，这样主调函数就可以使用那块堆内存
int* return_p(len){
    int *pArr = (int *)malloc(sizeof(int)*len);
    return pArr;
}
int main(int argc, char const *argv[])
{
    int len,i,*pArr;
    pArr=return_p(len);
    free(pArr); // 释放指针，把堆内存的控制权限还给系统
}
```

```c++
// 通过传递指针的地址进去，改变指针指向的地址为函数构造堆内存
void pp_to_p(int **a,int len){
    /*int **a = a;*/
    *a = (int *)malloc(sizeof(int)*len);
}
int main(int argc, char const *argv[])
{
    int len,i,*pArr;
    /*中间代码略*/
    pp_to_p(&pArr,len);
    free(pArr);/*释放指针，把堆内存的控制权限还给系统*/
}
```

```c
// 动态构造结构体
struct  Student
{
    int sid;
    int age;
};
struct Student *CreateStudent(){
    struct Student *s =(struct Student *)malloc(sizeof(struct Student));
}
void show_Student(struct Student *a){
    printf("%d %d\n",a->sid,a->age);
}
int main(int argc, char const *argv[])
{
    struct Student tom = {1,2};
    struct Student *ptim = CreateStudent();
    ptim->sid = 3;
    ptim->age = 45;
    show_Student(&tom);
    show_Student(ptim);
    return 0;
}
```
