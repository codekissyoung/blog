一个简单的程序 ：两数相加
```
​#include <iostream>
using namespace std;
int main()
{
    int a = 0,b = 0;
    std::cout<<"enter two numbers please!";
    std::cin>>a>>b;
    std::cout<<"a + b = "<<(a+b);
    return 0;
}
```
c++ 可以直接初始化变量，可以带来一些好处！

```
int x(1024);
```
c 语言中变量只能写在语句的前面，c++ 的变量是随用随定义的！更加方便！

```
std::cout<<"enter two numbers please!";
int a = 0,b = 0;
std::cin>>a>>b;
```
c  中的输入输出：
输入：输入设备 --->  输入流  ----> scanf  ---->变量
输出 ：变量---->printf -----> 输出流 ----->输出设备

c++ 中的输入输出：
输入 ：输入设备 ---->输入流 ---->cin ----> 变量
输出   : 变量 ---->cout ---->输出流 -----> 输出设备
带来的便利是： 不用关注占位符 %d 之类的，不用关注变量的数据类型了！

```
std::cout<<x<<endl;
std::cout <<"x + y" <<x+y <<endl;

std::cin>>y>>endl;
std::cin>>x>>y>>endl;
```
命名空间 : 解决的是类，函数，变量重命名问题！将它们用命名空间区分开，仅此而已！

```
​namespace  A
{
    int a(1024);
    void func();
}
namespace  B
{
    int a(1024);
    void func();
}
std::cout<<A::a;
B::func();
//或者
using namespace B;
int main(){
	func(); //等价于 B::func();
}
```


##引用：别名，外号而已。 ##

```
int a = 10;
int &b = a;			//引用必须初始化
b = 5;
std::cout<<a<<b;	//55
```
## 结构体类型引用 ##
```
#include <iostream>
int main()
{
    typedef struct{
    int x;
    int y;
    }Point;

    Point A;
    Point &B = A; 	//结构体引用
    B.x = 10;
    B.y = 11;
    std::cout<<A.x<<A.y;	//1011
}
```
## 指针类型的引用：引用是指针的别名，记住语法就行，理解语意就可！##
```
#include <iostream>
int main()
{
    int a   = 10;
    int *p  = &a;
	int *&q = p;     //记住这个语法
    *q = 20;         //使用 q ，跟使用p一样
    std::cout<<a;   //20
}
```
##使用指针和使用引用传参数的区别##

```
#include <iostream>
using namespace std;
void swap1(int* a,int* b){
    int c ;
    c  = *a;
    *a = *b;
    *b = c;
}
void swap2(int& a,int& b){
    int c;
    c = a;
    a = b;
    b = c;
}
int main()
{
//    swap1(2,3); //error	引用和指针都不能指向标量
    int a = 10,b = 20;
    swap1(&a,&b);           //还要使用取地址符，非常不方便
    std::cout<<a<<b<<endl;  //2010
    swap2(a,b);
    std::cout<<a<<b<<endl;  //1020
}
```
## const 修饰不变的量 ##

```
const int X = 5;   //x 为常量了
```
## const 修饰指针 ##
```
int x = 5;
const int *p = &x; //等价于 int const *p = &x;
*p = 10;//错误，不能通过该指针改变指向的值

int * const p2 = &x;
p2 = &y;//错误，指针本身不能变

const int * const p3 = &x;//不能通过该指针改变指向的值 + 指针本身不能变
```
## const 修饰引用 ##

```
int x = 10;
const int& y = x;// 常量引用
y = 15;			 // 错误，不能通过该引用修改变量的值
```
## 将一个没有读权限的变量，赋给有读权限的指针或引用是错误的 ##

```
const int x = 10;
int *p = &x;    //错误
int &q = x;     //错误
```

## 函数默认值建议写在声明里，定义里不写 ##
```
int func(int i,int j = 10,int k);//错误，没默认值的参数必须靠左
int func1(int i,int j=5,int k=10); //声明
int func2(int i,int j,int k){      //定义
	...
}
```
## 函数重载：在同一个作用域下，用同一函数名定义多个函数，参数类型/个数不同 ##
```
int func(int x,int y){...}
int func(double x,double y){...}
int func(int x,int y,int z){...}
函数重载通过编译实现，编译后：
int func_int_int(...){...}
int func_double_double(...){...}
int func_int_int_int(...){...}
```
## 内联函数：将调用函数体里面的代码，copy到调用处，省去了调用函数的开销 ##
```
inline int func(...){...}
//递归函数不能使用 inline 
//逻辑简单，调用频繁的函数建议使用inline
```

## 申请内存new,释放内存delete ##

```
int *p =new  int;
delete p;
```
## 申请和释放块内存 ##
```
int *arr = new int[10];
delete  []arr;	//记住这个语法
```
## 回顾c语言申请和释放内存 ##
```
void  *malloc(size_t  size);
void  free(void *memblock);
```
## 申请内存失败 ##

```
int *p = new int[10000];
if(NULL == p){
	//内存申请失败处理
}
delete []p;
p = NULL;//指针在回收后必须设置为 null
```

## 类 ##
```
class TV{
	public://访问限定符：public|protected|private
	TV(char _name){//init code}; //构造函数，在实例化类时执行，可以重载
	TV():name("codekissyoung"),type(0){};//构造函数初始化列表，记住这种写法就好
	TV(const TV& tv){};//拷贝构造函数，在使用一个已存在的对象去构造另一个对象时调用
	～TV(){};//析构函数：对象销毁时调用，一般用来释放资源，销毁堆内存
	char name[20];//成员函数
	int type;
	
	change_voice();//方法
	power();
};
```
## 从栈中实例化对象 ##
```
TV  tv1;	//定义一个对象
tv1.name = "长虹";	//访问数据成员
tv1.change_voice();
TV  tv2[10];//定义对象数组
```
## 从堆中实例化对象 ##

```
TV  *p = new TV();
p->name = "长虹";	//访问数据成员
TV	*parr = new TV[20];
p[2]->name = "长虹";	//访问数组中的第三个对象的成员
delete p; p = NULL;	//清除对象
delete []parr; p = NULL; //清除对象

```

## 类的专业写法：分文件类外定义 ##
Car.h
```
class Car{
	public:
	void run();
	void stop();
	void changeSpeed();
};
```
Car.cpp
```
#include "Car.h"
void Car::run(){...}
void Car::stop(){...}
void Car::changeSpeed(){...}
```
## 对象生命周期 ##
申请内存  ,初始化列表，构造函数，参与运算，析构函数，释放内存。

## string类型 ##
```
#include <iostream>
using namespace std;
#include <string>
int main()
{
    string name = "codekissyoung";
    string name2("zhangjian");
    cout<<name<<endl<<name2<<endl;
}
```





