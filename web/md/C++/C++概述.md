# 继承自C
- C++ 继承了 C 高效 简洁 快速 和 可移植性

# 泛型编程
- C++ 的模板特性提供了另一种全新的编程方法 ：泛型编程
- 目标：使重用代码和抽象通用概念的技术更简单
- 泛型 generic 指的是 创建独立于类型的代码
- 比如要对不同类型(整数 小数 字符 字符串 用户定义的类型)的数据进行排序，通常必须为每种类型创建一个排序函数，然而通过写一个泛型函数，就可以将其用于各种实际类型

# 面向对象
- OOP：对象 类 封装 数据隐藏 多态 和 继承
- 多态: 可以为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义
- 继承: 能够让你使用旧类派生出新类
- OOP的本质就是设计并且拓展自己的数据类型，让设计的类型与现实数据相匹配

# 面向过程 与 面向对象
- 面向过程 强调的是 **算法** ， 面向对象强调的是 **数据**
- 面向对象的重点不是处理任务，而是表示概念

# Why C++
- “我们的系统已经是极度复杂的了，为了避开C++的复杂性而干脆不用C++（Linus的做法），无异于因噎废食。”在所有可用C和C++的领域，C++都是比C更好的语言。当我说“更好的”时候，我说的是C++拥有比C更安全的类型检查、更好的抽象机制、更优秀的库。当然，凡事都有例外，如果你做的项目1）不大。2）编码中用不到什么抽象机制，甚至ADT（抽象数据类型，例如std::complex这种不含多态和继承的）也用不到，RAII也用不到，异常也用不到。3）你连基础库（如，简化资源管理的智能指针、智能容器）都用不着。那么也许你用C的确没问题；所以如果你的情况如此，不用和我争论，因为我无法反驳你。我们这里说的领域大致是Bjarne在“C++应用列表”里面列出来的那些地方。

- 底线是：如果把C++中的诸多不必要的复杂性去掉，留下那些本质的，重要的语言特性，简化语言模型，消除历史包袱。即便是C++的反对者也许也很难找到理由说“我还是不用C++”。在我看来，一个真正从实践意义上理性反对使用C++的人只有一个理由：C++的复杂性带来的混乱抵消乃至超过了C++的抽象机制和库（在他的特定项目中）带来的好处。

- 值得注意的是，这里需要避免一个陷阱，就是一旦人们认定了“C++不好”，那么这个理由就会“长出自己的脚来”，即，就算我们拿掉C++的复杂性，他们可能也会坚持还是不用C++，并为之找一堆理由。我假定你不是这样的人。不过，也许最可能的是他会说：“问题是我们今天用的C++并非如此（简洁），你的假设不成立。”是的，我的假设不成立。但虽然我们无法消除复杂性，我们实际上是可以容易地避开复杂性，避短扬长的。这也是本文的要点，容我后面再详述。
