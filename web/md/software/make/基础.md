# Make
- **将源代码转换成可执行文件** 的自动化
- 将程序各元素之间的关系告诉 Make , Make 会根据这些关系和时间戳判断应该重新进行哪些步骤，以重新产生你需要的程序

# makefile文件
- Make程序读取makefile文件，根据它来编译程序

# 默认规则
```makefile
target: prereq1 prereq2
    commands
```

# 只使用默认规则编写的例子
```makefile
count_words: count_words.o lexer.o -lfl
    gcc count_words.o lexer.o -lfl -o count_words
count_words.o: count_words.c
    gcc -c count_words.c
lexer.o: lexer.c
    gcc -c lexer.c
lexer.c: lexer.l
    flex -t lexer.l > lexer.c
```

# GNU make -l<NAME>
- `-lfl` 其中 `-l`是选项，表示gcc必须将系统程序库`libfl.a`链接进Program
- GNU make 对 `-l<NAME>` 语法提供特别支持，make会优先搜索 `libNAME.so` 如果找不到，再搜索 `libNAME.a`, 进行链接

# 两阶段执行模型 two phase execution model

# 递归变量 recursive variable

# 错误提示
```bash
make: `count_words` is up to date.  表示目标已经是最新编译版
make: *** No rule to make target `lexer.o`.Stop   表示编译成lexer.o的规则没写，或者有问题
```

# Make 执行选项
- `make --just-print` 打印 make 将要执行的命令，但不实际执行它们


# 较完整的默认规则
```makefile
target1 target2 target3 : prereq1 prereq2 prereq3 ...
    command1
    command2
    command3
    ...
```
- `\t`开头，后面的字符会被当做 commands , 传给 subshell 执行，如果在非命令行前面加上了`\t`，会报错
```
Makefile: *** commands commence before first target . Stop
```
- `#` 是注释
- `\` 是另起一行，来延续过长的文本

# 具体规则 explicit rule
```makefile
# 确定 vpath.c 在编译之前， lexer.c 已经存在
vpath.o : lexer.c

# 使用特殊的标记来编译 vpath.c
vpath.o : vpath.c
    $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

# 引入别的依存关系
include auto-generated-dependencies.d
```
# 模式规则 pattern rule
- 与Bash一致的通配符匹配文件规则 : `~` `*` `?` `[...]` `[^...]`
- `~` 匹配用户主目录

# 隐含规则 implicit rule

# 后缀规则 suffix rule

# 静态模式规则 static pattern rule

# 假想工作目标
```makefile
# .PHONY 告诉 make , 该工作目标 不是一个真正的文件
.PHONY: clean
clean:
    rm -f *.o lexer.c
# all工作目标会创建一个 bash 和 一个bashbug
.PHONY: all
all: bash bashbug

.PHONY: make-documentation
make-documentation:
    df -k . | awk 'NR == 2 { printf("%d available\n",$$4)}'
    javadoc ...
```

# 标准假想工作目标
```Makefile
all         执行编译应用程序的所有工作
install     从已编译的二进制文件中进行应用程序的安装
clean       将产生自源代码的二进制文件删除
distclean   删除编译过程中产生的任何文件
TAGS        建立可供编辑器使用的标记表
info        ...
check       执行与应用程序相关的任何测试
```

# 变量
- 单字符可以不用 `()` `{}` 去解引用
```
$(variable-name)
```

# 自动变量
- `$@` 工作目标的文件名
- `$<` 第一个必要文件名
- `$?` 所有必要文件，空格隔开
- `$^` 所有必要文件(已经去重)
- `$%`
- `$*` 工作目标的主文件名
```makefile
# 替换成自动变量的例子
count_words: count_words.o counter.o lexer.o -libfl
    gcc $^ -o $@
count_words.o: count_words.c
    gcc -c $^
counter.o: counter.c
    gcc -c $^
lexer.o: lexer.c
    gcc -c $^
lexer.c: lexer.l
    flex -t $< > $@
```
