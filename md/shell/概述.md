# shell可以做什么
- 管理主机的任务有查询登录文件、追踪流量、监控用户使用主机状态、主机各项硬件设备状态、主机软件更新查询
- 追踪和管理系统的重要工作
- 简单入侵检测功能
- 连续命令单一化
- 简易的数据处理
- 跨平台支持与学习历程较短
- Linux启动中，各种服务的自动开启
- 清除过期文件、机器老化、自动化测试等等的无人值守执行
- 软件开发的持续集成，提交代码后，迅速编译、打包、运行测试，给出反馈
- 各种服务器、数据库的维护、备份

# Bash 特征
- 目录处理,包含 pushd, popd 和 dirs 命令
- 作业控制,包括 `fg` 和 `bg` 命令,以及使用CRTL-Z停止作业
- 大括号扩展,可以产生任意的字符串
- `~`扩展,指代用户根目录的缩写
- 别名,让你为命令或命令行定义缩写名称
- 命令历史,让你记得以前输入的指令
- 命令行编辑,使用emacs或vi风格
- 键盘绑定,让你设置自定义编辑的键序列
- 集成编程特性,包含几个 UNIX 外部命令的功能,包括 test、expr、getopt、echo 等,使得编程任务能更简洁有效地完成
- 控制结构,特别是select结构,能简单生成菜单
- 新的选项与变量,使得你有更多的途径来定制你的环境
- 一维数组,使得引用与操作数据列表更为简单
- 动态加载built-in命令,自定义命令并加载进shell的功能。

# 启动方式
#### 交互式启动 Login-shell
交互式 login 启动时读取以下系统级别和用户级别的启动文件;交互式 non-login 启动时读 取以下 Bash 级别启动文件
1. 系统级别,由 `/etc/profile` 文件控制。这个文件在Bash shell启动时被执行。它可被系统所有 sh 和 ksh 用户使用。
2. 用户级别,由 `~/.bash_profile` (或者 `~/.bash_login`,或者 `~/.profile` )和 `~/.bash_logout` 文件控制。这些文件控制登录用户的基本登录和退出环境。
3. Bash 级别(子 shell 级别),由 `~/.bashrc` 文件控制。每次一个新的 Bash shell 启动时 将自动执行 `~/.bashrc` 文件,用来配置只属于 Bash shell 的环境。

- `~/.bashrc` 一般会含有以下语句

```bash
if [ -f /etc/bashrc ];
    then . /etc/bashrc
fi
```
`/etc/bashrc` 一般用来设置所有 Bash shell 公用的变量

- 系统配置文件/etc/profile文件中一般有如下语句

```bash
for i in /etc/profile.d/*.sh ;
    do if [ -r "$i" ]; then
. $i
fi done
```
系统会在初始化时运行 `/etc/profile.d/` 目录下的所有可读.sh 脚本。

- 用户级别的三个登录配置文件(~/.bash_profile,~/.bash_login和~/.profile)中,只会 source 一个(依次查找,一个不存在,查找下一个,找到就 source 它)。~/.profile 是为从 sh 和 ksh 的配置文件.profile 而来,~/.bash_login 是从 csh 的配置文件.login 而来。这种机制的一个应用是如果你经常使用 Bourne shell,你可以将其配置写 在.profile 文件中,如果你又想增加 Bash 特有的环境控制命令,你可以将其在写 入.bash_profile 文件中,然后在.bash_profile 中加入 source .profile 语句。

- 用户登录时默认不会 source ~/.bashrc 文件,如果要用需要自行在脚本中加入。这 也是一般在.bash_profile 文件中有以下语句的原因:
```bash
if [ -f ~/.bashrc ];
    then . ~/.bashrc
fi
```

- .bash_profile和/etc/profile中定义的变量和alias定义默认不会继承到bash中。需要这两个文件定义的变量可以为子 shell 使用时可以使用 export 语句将其转化为环境变量。alias 定义尽量放在.bashrc 或/etc/bashrc 文件中。

- 所有配置文件的执行顺序如下
```bash
|- /etc/profile --> /etc/profile.d/*.sh
|- ~/.bash_profile (or ~/.bash_login, or ~/.profile)
|               --> ~/.bashrc
|                        -->  /etc/bashrc
|- ~/.bash_logout (退出时)
```

- 但应注意,系统只自动读取`/etc/profile`, `~/.bash_profile` 和 `~/.bash_logout` ,其余是自 定义的。

#### 非交互式启动
当 Bash 通过运行 shell 脚本的方式启动时就是非交互式的。非交互式启动时,它将查看环 境变量 BASH_ENV,扩展其值并运行它,就像运行了以下命令:
```bash
if [ -n "$BASH_ENV" ] ;then 
    . "$BASH_ENV";
fi
```
但是 PATH 变量不用来查找文件名。

- 判断shell是否是交互式启动可通过以下方式
```bash
case "$-" in
    *i*) echo This shell is interactive ;;
    *) echo This shell is not interactive ;;
esac
```

- 检查 PS1, 非交互式 shell 它不会被设置
```bash
if [ -z “$PS1” ]; then
    echo This shell is not interactive
else
    echo This shell is interactive
fi
```

- 当shell交互式启动时,有以下不同于非交互式启动的行为:
1. 读入初始化文件;
1. 作业控制默认启动;
1. 显示PS1,PS2;
1. 命令行编辑功能;
1. 命令历史功能
1. 别名扩展
1. 定期检查邮件,根据 MAIL, MAILPATH, MAILCHECK 配置
1. 扩展错误、重定向错误、exec错误、解析命令错误等不会引起Bash退出
1. 检查TMOUT的值,如果固定秒在打印 $PS1 后没有命令读入退出

# Login Shell
借用《鸟哥的linux私房菜》中的定义：
> 取得 bash 時需要完整的登入流程的，就稱為 login shell。舉例來說，你要由 tty1 ~ tty6 登入，需要輸入使用者的帳號與密碼，此時取得的 bash 就稱為『 login shell 』囉；

除过上面获取login shell的方式外，我们还可以通过在non-login shell中运行
`bash --login`来得到一个login shell。
login shell启动时的配置文件读取流程如下
```bash
execute /etc/profile
IF ~/.bash_profile exists THEN
    execute ~/.bash_profile
ELSE
    IF ~/.bash_login exist THEN
        execute ~/.bash_login
    ELSE
        IF ~/.profile exist THEN
            execute ~/.profile
        END IF
    END IF
END IF
```
当我们退出或者注销login shell时，也有需要执行如下流程：
```shell
IF ~/.bash_logout exists THEN
    execute ~/.bash_logout
END IF
```

# Non-Login Shell
借用《鸟哥的linux私房菜》中的定义：
> 取得 bash 介面的方法不需要重複登入的舉動，舉例來說，(1)你以 X window 登入 Linux 後， 再以 X 的圖形化介面啟動終端機，此時那個終端介面並沒有需要再次的輸入帳號與密碼，那個 bash 的環境就稱為 non-login shell了。(2)你在原本的 bash 環境下再次下達 bash 這個指令，同樣的也沒有輸入帳號密碼， 那第二個 bash (子程序) 也是 non-login shell 。
譬如在Ubuntu中，我们启动的Gnome Terminal，在默认情况下就是一个non-login shell。non-login shell启动时的配置文

件读取流程：
```bash
execute /etc/bash.bashrc
IF ~/.bashrc exists THEN
    execute ~/.bashrc
END IF
```

shell编程要注意什么
================================================================================
- 命令从上而下，从左至右分析和执行
- 命令、参数间的多个空白会被忽略
- 空白行也会被忽略
- 如果读取到一个Enter符号，就尝试执行该行命令
- 如果一行代码太多，可以用[enter]来进行扩展
- #作为注释

Bash 的实现原理
================================================================================
bash使用GNU Readline库处理用户命令输入，Readline提供类似于vi或emacs的行编辑功能。
bash运行时的调度中心是其主控循环。主控循环的功能较为简单，它循环读取用户（或脚本）输入，传递给
语法分析器，同时处理下层递归返回的错误。
语法分析器对文本形式的输入首先进行通配符、别名、算术和变量展开等工作，然后通过命令生成器得到
规范的命令结构，并由专门的重定向处理机制填写重定向语义，交由命令执行器执行。命令执行器依据
命令种类不同，执行内部命令函数、外部程序或文件系统调用。在命令执行过程中，执行器要对系统信号
进行捕获和处理。在支持作业管理的操作系统中，命令执行器将进程信息加入作业控制机制，并允许用户
使用内部命令或键盘信号来启停作业。如果在不支持作业管理的操作系统中编译bash，会使用另一套接口
相同的机制对进程信息进行简单的维护。


如何执行shell脚本
================================================================================
- 绝对路径：/path/to/your/shell.sh
- 相对路径: ./shell.sh
- 将shell.sh存放在PATH指定的目录
- 以bash进程来执行：bash shell.sh sh shell.sh
- 利用直接执行的方式来执行script:该script会使用一个新的bash环境执行的脚本内容，中途产生的变量不会回传到父进程中
- 利用source执行脚本，会在父进程中进行


# C 特点
1. 计算机众多语言中，C是最基础、影响面最广的语言。K&R的《The C programming Language》，就定义了新语言的第一个程序学习模式，"Hello, World"
1. 语言编写的软件中，C的贡献是最高的，没有之一。Linux Kernel、Shell，直接用C实现；C++、Python、Java、PHP、ObjectC等等，你我能想到的如今的流行语言，几乎都是C语言实现的（或实现了早期版本，后期版本，有的用C++实现）
1. C简单、易理解、复用性强、移植性高，是常规软件中算法实现的最好选择之一（如果还要更快，可以用CPU相关语言，如Intel IPP，Arm NEON；再快，用FPGA；再快，用专用芯片；再快，花钱买更强的硬件）

# SHELL 特点
- Shell是一门语言，更是一个集成平台，是开发人员工作的基础之一（也许有意无意地被忽略，我们没有意识到）。只要开发人员在，开源世界就在；只要开源世界在，Linux就在；只要Linux在，Shell就在。（练习K&R的《The C programming Language》的习题时，编辑、编译、运行，都在用Shell。
- Shell是一个更深层次的系统入口，通过她你可以进入计算机世界，去探索另一个时空的神秘微妙；其他语言主要是“为用户服务”，对此涉及较少（深入理解计算机，能为用户提供更好的服务）。
- Shell实现功能快，灵活多变，掌握她，你会多一种或若干种设计思想和编程范式，面对问题，可以从容淡定地选择适合的方案。如果是你是开发人员，对于Shell，你可以赞扬她（很显然我属于这一类），也可以贬低她，但你不可能忽略她（其实你可以忽略她，但要承担对应后果）。

# C 与 SHELL 差异
1. 文件差异
    - Shell中，经常听到的是；执行程序，查找文件，删除文件，批量改变文件名，备份文件...列出目录的文件，Shell中只需一条命令(ls)。

    - C中，经常听到的是：字符串长度，整数小数，精确度，循环边界值，执行次数...一个浮点矩阵乘法，C中几个数组、两个for循环搞定。
    
    - Shell的基本粒度在文件级别，特别适合文件系统的操作和改进；C是基本粒度在数据类型级别，特别适合算法层次的实现和应用。

1. 性能差异
    - 系统启动时的调用、文本转换、等待用户响应等，如果给用户的响应在秒级别（假设C就算比Shell快10000倍），或不要用户干巴巴坐等，用户感觉应可接受，或不在乎。
    - 影音播放、大数据传输、实时控制同步XX机器人等，最理想就是没有延迟，快1秒、毫秒、微秒、纳秒，都有它的应用场景。
    - Shell是解释性语言，性能比C低，大多应用场景已能满足要求（以人的主观角度）；对实时响应、实时控制、大数据处理等，还是要用C。
    - 一个现状是，硬件性能越来越强，对软件本身性能，是个福音（但现在应用软件也越做越庞大、越来越好看，消耗的性能也持续增加）。

1. 环境差异
    - Shell中，除了内建命令，大多是运行其他程序。这些程序各自实现一个个小目标，本身是可以独立运行的；在Shell的组织下，共同努力，集成为一个大目标。（我想起了王健林的“小目标”、美国的“联邦分权制”）
    - C中，除了关键字，主要就是调用各种库提供的接口函数。这些接口本身不会独自工作，按错误顺序调用也不工作（可能工作，但结果异常）；各种库的接口之间可能不兼容，因为她们不是按一个个独立小目标来实现的，更多是通用实现。如果使用者能正确、精确调用，效果巨大。
    - Shell中直接运行可执行程序；C中链接库，或通过system(cmd)子进程运行程序（有效获取运行程序的数据，又是一项专业技术活）
    - 从结果看，都达到了目的，没有谁好谁坏之分；从过程看，独立自主的“小目标”成就感更及时。何况，你我实现的，可能只是“小小目标，或者小小小目标”

1. 进程差异
    - Shell中，一不小心就创建了进程。在命令行中，每一次回车的成功执行一个脚本或程序，都创建了至少一个进程。进程之间的通信和数据分享，常规通过退出状态、管道、文件，使用简单，但非常实用。特别强调一下管道（Pipe），这是一个了不起的发明（至少可以和文件系统媲美），数据如水流送入管道，进程像过滤器，对管道中流过的水流进行加工，去除、加入、或转换。如果不创建进程，或进程通信、数据分享复杂，Shell脚本可能没有这么大的影响。
    - C中，创建进程相对复杂；但设计进程间通信的机制、数据共享，就更为复杂；而为什么要用多进程，又是更高层次的复杂问题了。多进程的设计，一直都是真正C程序员的一个生死考虑。实际上，- C 中更常见的是“单进程、多线程”设计，在一个进程内，划分为“多重性格”捣腾。实际中，线程的同步、临界资源、优先级等，对资深程序员往往也是一个高难度考验。
    总的来说
    - Shell中，进程是柴米油盐酱醋茶，实用品，呼之即来，挥之则去；
    - C中，进程是奢侈品，不是什么人都玩得起，多少人在她的小闺蜜“线程”前面，就死翘翘了。

1. 内存差异
    - Shell中，主要是“Shell内部”和“调用独立程序”两类地方要使用内存，Shell内部，内存由Shell解释器管理；调用的独立程序，则由独立程序内部自行管理。不论是脚本，还是程序，一旦执行完毕，内存都由操作系统回收，重新分派。进程Shell用户，不用管理内存。这是一个“使用者角度”的福音（一些编译型语言，也提供用户不管内存的“资源自动回收机制”了，如Java、Python），把内存管理风险，转移到Shell解释器和独立程序中。
    - C中，就是独立程序的一种实现，内存管理逃无可逃。内存的分派、使用，本身并不难，难的是随时都要检查异常，并做好预防。内存对程序来讲，就是空气对人一样，必需、重要、而且好获取，但是大家在陆地上生活久了，都忽略了。看看海洋中潜水员、太空中的宇航员，氧气罐是他们时刻关注，因为关乎于能否继续活着？
    内存是程序运行的必备资源，Shell中，我们把球踢出去，自己不关心；C中，内存管理，是多少英雄成功崛起的“竞技场”，也是无数豪杰殊途同归的“英雄冢”。

1. 编程差异
    - Shell中，变量全部是字符串，数值计算需要特殊语法支持；支持条件if，循环for、while、until，分支break、contine、case等，函数定义，功能和C差不多，但语法有区别；提供简单的数组（能不用不用），甚至还提供了指针用法（千万不要用）！输入输出（I/O）操作简单，“I/O重定向 + 管道”已经成为经典应用。因为经常做文件相关的查询（文件名、文件属性等），并执行后续操作，所以Shell在测试语句写法、字符串操作、文件判断等方面的操作，提供得多快好省。
    - C中，变量为基础数据类型，更多的是数值类型，字符串只是其中一种（也是很强大的一种）；条件、循环、分支、函数定义很常规，有自定义数据结构struct，还包含非常强大的数组、指针，输入输出中规中矩。特别强调是结构体、数组、指针，这是C除了数值运算，还能组织实现Linux这种超大规模代码的基础。虽然上手比较难，但对C专家来说，这些“水土火气”基本元素，就能构成多彩的代码世界。
    编程语言的语法、基本元素，是入门学习的第一步。编程语言有最基本的实现要素，理解这一点后，入门主要是适应撰写的习惯，更重要的是找到最适合的应用场景，使用最适合的工具来完成。

# Linux与Shell
- Linux系统
    1. 最神秘是Kernel，她填补了开源世界最核心的部件，之后开源软件才能自己独立玩了；
    1. 最多彩是DeviceDriver，她满足了创造的欲望，专业、业余的DIYer，都可以为开源软件添砖加瓦了；
    1. 最亲密是Shell，她提供了一个“虫洞”，我们可以通过她，进入神秘多彩的计算机时空，体验高维度生物的行为思想（现实时空，也许就是高维度生物的游戏场所）；
    1. 最暖心是各种Tools，你找到她们，她们就会给你惊喜或沉溺；你找不到，就自己苦逼或幸运吧。

- Shell简介
    1. Shell是一个命令解释器。用户通过Shell，可以使用和控制 Kernel、Device Tools 的资源。

# shell的用武之地
1. 快速实现软件原型
    - 在管理中，我们经常听到类似的话：“方向比速度更重要，选择比努力更重要”。软件工作也一样：先满足正确性，否则性能没有意义（其实快还是有意义的，能很快知道错了）。我们可以通过一个简单但实际例子来比较一下：把若干文件中固定格式的16进制数，转成10进制数另存，好方便人类查看。
    > 1. 打印出来，手工转换，用笔标注 正确性靠转换人保证（我想起一个电视中揭露的游戏“交20押金，从1写到500，全都正确给价值好几百的礼品或现金，错误则没收押金”，有人靠这个能挣钱养家糊口的）。时间基本和字节数成正比（假设转、写1秒1数）
    > 1. 使用C，写个Command程序 需要写源码，实现文件读写、内容按规则读取、字符串数字转换、数字进制转换等功能，然后编译、调试，完成程序后，在命令行调用。正确性靠人设计、通过数据来保证。时间包括写程序、调用文件、执行三部分，主要时间在“写程序”，其次在“调用文件”，“执行时间”最少
    > 1. 使用MFC，写个GUI程序（可以补充其他语言对比）和第2）种类似，只是多了GUI的设计、实现，完成程序后，可以用鼠标操作。时间也类似，只是有“命令行”和“GUI鼠标”的操作时间差异
    > 1. 使用shell，写个脚本 和第2）种相同，只是用脚本实现，不用编译。时间的差异有两点：“写程序”和“写脚本”，“编译程序的执行”和“脚本程序的执行”

    - 策略选择
    > 1. 如果只有100个数，人工方法最靠谱人工，什么写程序都是浮云。但电子信息的特点之一：信息特别多
    > 1. 如果用GUI实现，用得会很爽，鼠标指指点点搞定。开发时间则是最长的，而且一定要有人触发。如果每天都要操作，这个人会觉得枯燥，说不准忘记了。电子信息的特点之二：开发人员的数据处理，比终端用户多得多。这个进制转换的例子，其实就是开发人员的需求（终端用户，也许根本不知道16进制和10进制的区别。“我们连12点和0点都区不了”），他们在程序调用上，并不是电脑白痴，他们不喜欢当“白痴”
    > 1. 用command实现，不开发GUI（不用做GUI，开发很开心，因为美工实际是个艺术活，而不是技术活）时间少，主要时间是调试、逻辑差错时间。可以把执行命令复制下来，要处理就执行一下，方便快捷，但还是要操作。电子信息的特点三，信息随时来；软件开发特点一：调试、差错时间，比编码时间多得多
    > 1. 用脚本实现，没有GUI，代码比c少，直接运行调试。如果定点到，或数据多，可以定时执行，无人值守。完美。
    

1. 自动化使用
    - Linux启动中，各种服务的自动开启
    - 清除过期文件、机器老化、自动化测试等等的无人值守执行
    - 软件开发的持续集成，提交代码后，迅速编译、打包、运行测试，给出反馈
    - 各种服务器、数据库的维护、备份
    > 绝大多数场合，我们都是终端用户（衣食住行用），按黑盒子方式使用；偶尔一个微小的点（工作行业的产品），我们是研发生产人员。有时候，我们没有切换角色和思维，把盒子生产的要求点和标准，想得过于简单。
    
    > 相对终端用户（交互式、黑盒子方式使用，主要关注功能点、性能点、界面、操作流等），研发生产人员更要掌握（制造黑盒需要更多工具，盒子包括很多非用户需求：如快速调试、快速验证、快速发布，系统集成，运行资源监控、批量生产、异常现场信息收集、快速升级）。如果你要加强工作的自动化能力？Shell真的很不错。这是大家对Shell高手，敬仰之情如滔滔江水，连绵不绝的原因。

1. 集成实现更高级功能
    - 当今的人类世界，除了艺术品还是“单兵作战”模式，如哲学思想、绘画、书法、音乐等等（主要工作是单兵，大量的辅助还是被自动化了。像李宗盛这种，唱歌用自己做的吉他，做吉他用自己种的树，少了）；其他工艺品都切换到了“团队作战”模式，如出书、画展、演唱会、做手机、做App产品等等（还是需要单兵英雄，但是大量的工作需要支持）。
    - 而且，“团队作战”的模式，已经切换到“特种部队”这种快速响应模式，通过“少部分外部执行者（前台信息收集、决策） + 资源网络支持（后台数据处理、执行）”。这种模式能粘合、组装，利用已成熟工作的系统资源，集成实现更高级的目标（也可以叫组装、组合能力）。集成能力像胶水、螺丝、铆钉、绳子、包装袋、容器。。。
    - 软件开发中，相对硬件、其他有形产品，更容易集成（也许是“需求爆炸”的愿意之一）。Booch在《面向对象的分析与设计》中写到，软件开发团队的任务，是设计一种假象，对用户掩盖复杂性（专业术语是封装）。当然开发人员，必须承受其背后的复杂度。
    - 软件集成了硬件、固件、结构；应用程序集成了操作系统、驱动、网络；Shell，则为快速实现更高级的应用程序，提供了“特种部队”的集成能力、运行环境。










# `/etc` 配置文件
- `/etc/lilo.conf `   启动引导程序文件
- `/etc/grub.conf`     多系统引导时，配置文件
- `/etc/inittab `   控制启动模式（图形/文本登录）
- `/etc/fstab`   文件系统配置
- `/etc/profile`    增加环境变量等的配置文件 如PATH 如配置javaEE 开发环境
- `/etc/ftp*`    ftp 的配置文件
- `/etc/ssh*`    ssh的配置文件
- `/etc/resolv.conf`    dns域名服务器的配置文件
- `/etc/passwd`    系统能识别的用户清单，纯文本显示加密了的口令，普通用户可读
- `/etc/shadow`    超级用户才能读，用于保护加密口令的安全，隐藏口令
- `/etc/group`    放置所有组名的地方
- `/etc/sysconfig/network-scripts/ifcfg-etho`    ip地址的配置文件
- `/etc/hosts`    类似于window  host 文件的

# /dev/null
```bash
cat file 2>/dev/null # 将stderr重定向到 /dev/null ，这样就不会输出到控制台了
cat /dev/null > /var/log/file # 将file清空　，而又不删除它

if [ -f ~/.netscape/cookies ];then    # 如果存在则删除，删除后才可以添加软链接  
    rm -f ~/.netscape/cookies
fi    
ln -s /dev/null ~/.netscape/cookies  # 建立到/dev/null的软链接，这时所有该存到文件的输入都被丢入/dev/null了
```
- 或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。通常被用于丢弃不需要的输出流

# /dev/zero
```bash
dd if=/dev/zero of=/dev/sdb bs=4M # 把/dev/sdb 清零
```
- 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。
- 典型用法是用它提供的字符流来覆盖信息
- 另一个常见用法是产生一个特定大小的空白文件
- ELF二进制文件利用了/dev/zero

```bash
# 创建一个临时交换空间(类似于swap分区)
# 创建一个交换文件，参数为创建的块数量（不带参数则为默认），一块为1024B（1K）    
    
ROOT_UID=0         # Root 用户的 $UID 是 0.    
E_WRONG_USER=65    # 不是 root?    
    
FILE=/swap    
BLOCKSIZE=1024    
MINBLOCKS=40    
SUCCESS=0    
    
# 这个脚本必须用root来运行,如果不是root作出提示并退出    
if [ "$UID" -ne "$ROOT_UID" ]    
then    
  echo; echo "You must be root to run this script."; echo    
  exit $E_WRONG_USER    
fi     
      
    
blocks=${1:-$MINBLOCKS}          # 如果命令行没有指定，则设置为默认的40块.    
# 上面这句等同如：
# --------------------------------------------------
# if [ -n "$1" ]
# then
#   blocks=$1
# else
#   blocks=$MINBLOCKS
# fi
# --------------------------------------------------
if [ "$blocks" -lt $MINBLOCKS ]
then
  blocks=$MINBLOCKS              # 最少要有 40 个块长，如果带入参数比40小，将块数仍设置成40    
fi
echo "Creating swap file of size $blocks blocks (KB)."    
dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks # 把零写入文件.    
    
mkswap $FILE $blocks             # 将此文件建为交换文件（或称交换分区）.    
swapon $FILE                     # 激活交换文件.    
    
echo "Swap file created and activated."    
exit $SUCCESS
```

```bash
#!/bin/bash    
# ramdisk.sh    
# 为特定的目的而用零去填充一个指定大小的文件，如挂载一个文件系统到环回设备 （loopback device） 或"安全地" 删除一个文件。
# "ramdisk"是系统RAM内存的一段，它可以被当成是一个文件系统来操作.    
# 优点：存取速度非常快 (包括读和写).    
# 缺点: 易失性, 当计算机重启或关机时会丢失数据.    
# 会减少系统可用的RAM.    
# 那么ramdisk有什么作用呢?    
# 保存一个较大的数据集在ramdisk, 比如一张表或字典,这样可以加速数据查询, 因为在内存里查找比在磁盘里查找快得多.    
    
E_NON_ROOT_USER=70             # 必须用root来运行.    
ROOTUSER_NAME=root    
    
MOUNTPT=/mnt/ramdisk    
SIZE=2000                      # 2K 个块 (可以合适的做修改)    
BLOCKSIZE=1024                 # 每块有1K (1024 byte) 的大小    
DEVICE=/dev/ram0               # 第一个 ram 设备    
    
username=`id -nu`    
if [ "$username" != "$ROOTUSER_NAME" ]    
then    
  echo "Must be root to run ""`basename $0`""."    
  exit $E_NON_ROOT_USER    
fi    
    
if [ ! -d "$MOUNTPT" ]         # 测试挂载点是否已经存在了,    
then                           #+ 如果这个脚本已经运行了好几次了就不会再建这个目录了    
  mkdir $MOUNTPT               #+ 因为前面已经建立了.    
fi    
    
dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE # 把RAM设备的内容用零填充.    
                                                      # 为何需要这么做?    
mke2fs $DEVICE                 # 在RAM设备上创建一个ext2文件系统.    
mount $DEVICE $MOUNTPT         # 挂载设备.    
chmod 777 $MOUNTPT             # 使普通用户也可以存取这个ramdisk，但是, 只能由root来缷载它.    
    
echo """$MOUNTPT"" now available for use."    
# 现在 ramdisk 即使普通用户也可以用来存取文件了.    
# 注意, ramdisk是易失的, 所以当计算机系统重启或关机时ramdisk里的内容会消失.    
# 重启之后, 运行这个脚本再次建立起一个 ramdisk.    
# 仅重新加载 /mnt/ramdisk 而没有其他的步骤将不会正确工作.    
# 如果加以改进, 这个脚本可以放在 /etc/rc.d/rc.local，以使系统启动时能自动设立一个ramdisk。这样很合适速度要求高的数据库服务器.    
exit 0 
```







