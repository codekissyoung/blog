# sort
- `-f` 忽略大小写
- `-b` 忽略排序起始处的空白
- `-m` 将两个已排序数据文件合并
- `-g` 转换为浮点数后排序

```bash
sort file1.txt file2.txt > sorted.txt # 将两个文件里的内容排好序，存入另一个文件

sort -t: -k3 -n /etc/passwd # -t 以:为分隔符，-k 选择第3列作为排序依据
root:x:0:0:root:/root://usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...

du -sh * | sort -nr # -n 以数字大小排序，-r 反转排序方向
80K	lib
40K	src
32K	cky
20K	main.c
16K	include
12K	hello
4.0K	shell
4.0K	README.md
4.0K	Makefile
0	text.txt
```

# grep
- `grep [options] pattern [file]`
- `-v` 反向搜索,显示不匹配pattern的
- `-n` 显示行号
- `-c` 统计有多少匹配的行
- `-e` 指定多个pattern
- `-r` 递归

# wc
- 统计 行数 词数 字节数
```bash
➜  shell git:(master) wc < /etc/passwd
  46   78 2590
```

# uniq 去重
```bash
cat uniq.txt 
bash
foss
hack
hack

uniq uniq.txt # 去重
bash
foss
hack

uniq -u uniq.txt # 只显示唯一的行 
bash
foss

uniq -c uniq.txt # 统计出现行数
      1 bash
      1 foss
      2 hack
      1 

uniq -d uniq.txt # 找出重复的行
hack

uniq -s2 -w2 -c uniq_data.txt # -s 指定跳过两个字符，-w 指定只对比多少个字符
      1 u:01:gnu
      1 d:04:linux
      2 u:01:bash

uniq -z file.txt | xargs -0 rm # -z 给每行添加 \0 终结符，用以和 xargs -0 配合使用，使得每行被当做一个参数，而不是被空格隔开的好几个参数
```


# 排序
http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html
`sort -n`           将0-9识别为数字进行排序
`sort -t':' -k 3`   -t指定分割的字段，-k 3 表示根据分割的第三段排序
`sort -r`          逆序排列
例子：
我想让facebook.txt按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序：
`$ sort -n -t' ' -k 3r -k 2 facebook.txt`
baidu     100     5000
google    110     5000
sohu      100     4500
guge      50      3000
从公司英文名称的第二个字母开始进行排序
`$ sort -t ' ' -k 1.2 facebook.txt`
baidu     100     5000
sohu      100     4500
google    110     5000
guge      50      3000
只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序
`$ sort -t ' ' -k 1.2,1.2 -k 3,3nr facebook.txt`
baidu  100  5000
google 110  5000
sohu   100  4500
guge   50   3000

# grep搜索文本
`grep pattern files`  搜索匹配pattern的内容
`grep -r pattern dir`  递归搜索dir中匹配parttern的内容
`grep -v  file.txt`  输出没匹配到文本的行
`grep -n  file.txt`  显示行号
`grep -E '219|216' data.doc` 匹配带有 219 或者 216的行
`egrep Posix_regexp file.txt` 使用POSIX拓展正则表达式
`px aux |grep ngnix` 搜索匹配到ngnix的行

# 去重
这个命令读取输入文件，并比较相邻的行。在正常情况下，第二个及以后更多个重复行将被删去
uniq  -c  显示输出中，在每行行首加上本行在文件中出现的次数

# cut 提取列 :基本被awk替代
- cut只擅长处理 以一个字符间隔 的文本内容
```bash
cut -c 5 # 指定切出第５个字符
who|cut -c 3-5,8 # 指定切出第3到第5个字符,第8个字符
cut -f 列数 -d 分割符 file.txt
grep "/bin/bash" /etc/passwd |grep -v "root" |cut -f 1 -t :
```

# sed 替换
```bash
sed '2d' example # 删除example文件的第二行
sed '2,$d' example # 删除example文件的第二行到末尾所有行
sed '$d' example # 删除example文件的最后一行
sed '/test/'d example # 删除example文件所有包含test的行 
sed 's/test/mytest/g' example # 在整行范围内把test替换为mytest, 如果没有g标记，则只有每行第一个匹配的test被替换成mytest
sed 's/^192.168.0.1/& localhost/' example # &符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1 localhost
sed -n 's/\(love\)able/\1rs/p' example # love被标记为1，所有loveable会被替换成lovers，而且由于 -n /p ,只有替换的行会被打印出来 
sed 's#10#100#g' example # 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100
sed -n '/test/,/check/p' example # 打印两个匹配行之间的所有行
sed -n '5,/^test/p' example # 打印从第五行开始到第一个包含以test开始的行之间的所有行
sed '/test/,/check/s/$/end/' example # 对于模板test和west之间的行，每行的末尾用字符串end替换
```


# 查询某个文件的所有git提交记录详情
```bash
git log mcs_db_install.sql | grep commit | awk '{print "git show " $2}' | sh >> mcs_db_install-git-show-log
```
# 统计某个文件夹下所有.php文件中代码行数
```bash
find ./ -name "*.php"|xargs cat|grep -v ^$|wc -l
```
# 删除windows系统编辑文本产生的不可见字符`^M`
```bash
touch love_tmp.c
sed 's/^M//' $1 > love_tmp.c
mv love_tmp.c $1
```
操作符	说明	举例

`^M` 的输入方法为 `Ctrl + v` 再加上 `Ctrl + m`
`cat -v love.c` 可用来查看一个文件，特殊字符也会显示出来



