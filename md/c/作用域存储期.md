# 静态变量 static 实现
```c
void trystat(void){
    int fade = 1;
    static int stay = 2;
    printf("fade = %d , stay = %d \n",fade++,stay++);
}
```
- 静态变量，首先只有在定义它的函数内部才能访问到
- 在函数调用完毕 return 后，静态变量并不会被销毁，而是保持其值
- 这次调用 `trystat` 函数中静态变量的值，就是上次调用 `stystat` 结束时，静态变量保存的值
- 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

# 模块 static 实现
```c
// node.c
typedef struct node *Node;
static Node head;
int insert(int val){ ... }
void print(){ ... }

// node.h
extern int insert(int val);
extern void print();
extern void destroy();
```
- `static` 限制 `head` 只能在本文件中访问,用户企图在其他文件中直接操作 `node` 是不可能的
- 同时暴露出 `insert`  `print` 函数作为外部操作该链表的接口
- 在模块内，但在函数体外，一个被声明为静态的 **变量** 或者 **函数** 可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量

# 声明和定义
```c
// 声明
int a;
extern int max(int a,int b);

// 定义
int a = 10;
int max(int a,int b){ ... }
```
- 声明是只告知编译器该变量的存在,不分配存储空间
- 多个定义是错误的，多个声明是可以的
- 没有定义就把声明当定义,最后都是以定义为准

# extern 外来变量函数引用
- 置于函数或者变量前，告诉编译器 此变量和函数在其他模块（不在本文件）中寻找其定义。

# 局部作用域 {}
```c
int a = 5;
{
    int a = 10;
    printf("%f\n",a); // 10
}
printf("%f \n",a); // 5

int a = 10; //全局变量
int func(){
    int a = 20 ; //局部变量，屏蔽全局变量
}
int func2(){
    printf('%d',a); // 函数内部可以直接使用全局变量
}
```

# return 函数局部变量 错误
```c
char *Func(void){
    char str[30];
    return str;
}
```
- str    属于局部变量，位于栈内存中，在Func结束的时候被释放，所以返回str将导致错误。
- return 语句不可返回指向栈内存的指针 , 因为该内存在函数体结束时被自动销毁。
- return ; 这个语句没有问题，只表示函数的结束

# #define 和 const
```c
#define    M    3
const    int    N=5;    //此时并未将 N 放入 内存中
int    i = N;    //此时 为 N 分配内存，以后不再分配
int    I = M;    //预编译期间 进行宏替换 ，分配内存
int    j = N;    //使用    N    上次的内存
int    J = M;    //再进行宏替换，又一次分配内存 ！

const    int    a[5]={1,2,3,4,5};
const    int    *p;    //修饰指针    p 可变，p指向的对象不可变    修饰 *P
int    const    *p;    //修饰指针    同上    修饰    *p
int    *const    p;    //p    不可变，p 指向的对象可变    修饰p
const    int    *const    p;    //指针 p 和 p 指向的对象 都不可变    修饰 * 修饰 p

// 编译器 解析时 忽略类型名，并且 const 离谁近 ，就修饰谁;
void    Fun(const int　i);　// 告诉编译器，i 在函数体中 的值不能改变，从而防止了一些无意的修改
const    int     Fun(void);    //返回值不可 被改变
extern    const    int  i;   //在 另一个文件中 引用 const 只读变量
extern    const    int  j=10;    //错误，只读变量 的值 不能改变

const int nochange=11; /*nochange 为只读*/
nochange = 12;  /*报错*/
const int days[12]={31,30,28,30,31,30,31,30,31,30,31,30}; /*数组的值是只读的了*/
const float *pf;   /*指针指向的值是不变的*/
float const *pf    /*指针指向的值是不变的*/
float * const pt;  /*指针不能变*/
const float * const pf;    /*指针和指针指向的值均不能变*/
void display( const int array[], int limit );    /*array指向的值是不能变的*/
void display( const int *array, int limit );    /*array指向的值是不能变的*/
char *strcat( char *, const char* ); /*如果传入函数中的内存地址处的值只是用来 读取的，就const ;如果是要改变的，那就不加*/
```
- 从 汇编 角度: `const` 给出的是变量对应的内存地址，所以在运行过程中只有一份，为只读变量 ，放在静态区，具有特定的类型
- `#define` 给出的是立即数，宏是在预编译时进行替换，有若干个拷贝，没有类型
- const 可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。



