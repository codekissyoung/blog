# 内核缓冲
- 内核使用缓冲来提高对磁盘的访问效率
- 内核将磁盘上的数据块复制到`内核缓冲区`，进程读取磁盘数据时，内核一般不直接读磁盘，而是将`内核缓冲区`的数据复制到`进程缓冲区`中
- 当进程所要求的数据不在`内核缓冲区`时，内核会把相应的`数据块读取请求`放入`内核请求队列`中，然后将进程挂起，接着为其他进程服务，一段时间后，当内核把相应的数据块从磁盘读取到`内核缓冲区`后，再唤起被挂起的进程，将数据从`内核缓冲区`复制到`进程缓冲区`
- `read()`系统调用实质是将`内核缓冲区`的数据复制到`进程缓冲区`
- `write()`系统调用的实质是将`进程缓冲区`数据复制到`内核缓冲区`
- `内核缓冲区`的数据写入磁盘也不是立即写入，而是积累到一定数量后，一次性写入磁盘
- 并不是所有的`write()`操作都能实质改变磁盘的数据。比如出现突然断电情况，内核来不及把内核缓冲区的数据写到磁盘上，这些更新的数据就会丢失。

# 处理系统调用的错误
- `open()`无法打开文件，`read()`无法读取文件，`lseek()`无法指定指针位置...等等系统调用，都返回 `-1`
- `-1` 就表示系统调用中出了问题，所以调用者每次都需要检查返回值，一旦检测到错误，就必须做出相应处理
- 错误种类: `全局变量errno` 用于指明错误的类型, 程序中任何地方都可以访问到这个变量

```c
#include <errno.h>
extern int errno;

if( (fd = open( "file1", O_RDONLY )) == -1 )
{
    if( errno == ENOENT )
        printf("there is no such file!");
    else if( errno == EINTR )
        printf( "interrupted while opening file!" );
    ...
}
```
- 显示错误信息 `perror("can not open file");`
