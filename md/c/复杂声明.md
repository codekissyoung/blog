# [将c声明转化为英语描述的工具](https://cdecl.org/)

- `()` `.` `->` `[]`  这四个运算符的优先级最高
- `++p_rule->len` 和 `++rule.len` 都是将 `len` 的长度自增, `*p->str++` 则是将str指向处的值++
- `int p`  这是一个普通的整形变量
- `int *p` 这是一个指针，指针指向的内容为整型数据
- `int p[3]`   这是一个普通的数组，有3个元素，每个元素的数据都是整型
- `int *p[3]`  p先于`[]`结合，说明这是一个数组，里面有3个元素，再与`*`结合，说明每个元素的类型都是指针，再与`int`结合，说明每个指针都指向`int`型
- `int (*p)[3]` p先和`*`结合，说明是一个指针，然后与`[]`结合，指针指向的内容是一个数组，该数组有3个元素，再与int结合，说明每个元素都是int型
- `int **p` 一个普通的二级指针
- `int p(int)`  一个普通的函数p，返回值为int型，函数参数为int型
- `int (*p)(int)` `*p`是一个指针，再与`()`结合，说明指针指向一个函数,该函数参数为int型，再结合最左边的int，函数的返回值也是int型

```c
char (*comp)()
```
- `(*comp)` comp解引用，这说明comp是个指针
- `(*comp)()` comp解引用后调用，这说明comp是个函数指针
- `char (*comp)()` comp解引用后调用的返回值是char，这说明comp是个返回值为char的函数指针

```c
char (*(*X())[])()
```

- `X()` X调用，这说明X是个函数
- `(*X())` X调用的返回值解引用，这说明X是个返回值为指针的函数现在X是什么已经清楚了，现在的关键是其返回值的类型(用P表示)。
- `(*X())[]` P解引用后可以用[]运算，这说明P解引用后还是个指针
- `(*(*X())[])` P解引用后用[]运算之后的值还可以用 `*` 运算，这说明P解引用后再解引用还是个指针
- `(*(*X())[])()` P解引用后用[]运算之后再用 `*` 运算后可以调用，这说明P三次解引用后是一个函数
- `char (*(*X())[])()` 该函数返回一个char
- 总结： X是个返回值为指针的函数，该指针解引用三次后是一个返回值为char的函数。

```c
// 原声明 ,变量名为b,先往右看,明显为一个数组
void (* b[10])(void ( * )());

// 先简化(void( * )())
typedef void (* pFunParam)();
// 然后再简化原声明
typedef void (* pFunx)(pFunParam);
// 下列声明等价原声明
pFunx b[10];

// 原声明，变量名为e,
double (*)()(* e)[9];
// 别名一
typedef double(* pFuny)();
// 别名二
typedef pFuny (* pFunParamy)[9];
// 等价原声明
pFunParamy e;

// 原声明
// 首先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针
// 然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*func)是一个函数,所以func是一个指向这类函数的指针，即函数指针
// 这类函数具有int*类型的形参，返回值类型是int
int (* func)(int * p);

// 原声明
// func右边是一个[]运算符，说明func是具有5个元素的数组；
// func的左边有一个 *，说明func的元素是指针（注意这里的 * 不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比 * 高，func先跟[]结合）
// 跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有 int * 类型的形参，返回值类型为int
int ( * func[5])( int * )
```

- 为复杂的声明定义一个新的简单的别名
- 复杂声明查看原则 : 从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完